---
title: "MuSu_(NA, c, MFA_subs) - MSC All Subjects (N=10) Big Networks 4 Sessions (rows)"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(pander)
library(psych)
library(DistatisR)
library(tidyverse)
library(magrittr)
library(PTCA4CATA)
library(ExPosition)
library(InPosition)
library(MExPosition)
library(superheat)
library(gridExtra)
library(ggplotify)
library(grid)
library(RColorBrewer)
library(pals)
# Read functions -----------------------------------
tool.path <- "../../../tools/"
source(paste0(tool.path,"SScomm.R")) # SScomm.R: computes SS of a square matrix based on a design matrix
source(paste0(tool.path,"vec2sqmat.R"))
source(paste0(tool.path,"getVoxDes.R"))

#### == DEFINE Parameters (e.g., subj name, paths) == ####
# This section will hopefully become parameterized for RMD in the future 

parcelfile2read <- sapply(X = 1:10, FUN=function(x){sprintf("/sub-MSC%02d_node_parcel_bigcomm.txt",x)})
subj.name <- paste("sub", sprintf("%02d",1:10), sep="")

parcel.comm.path <- "../../../data/parcel_community/bignetwork"
CommName <- read.csv("../../../data/parcel_community/bignetwork/systemlabel_bigcomm.txt",header = FALSE)
parcel.comm.path <- "../../../data/parcel_community/bignetwork"

# Load Grand Table
# gt: grand tabls
# labels: information for each edge in the rectangular grand table
load(paste0("../../../data/grandatble_and_labels_bignetcol_MSC_allsubs_N10_20190620.Rdata")) # read the labels of grandtable

## Categorize columns by between or within edges
#--- Create new column of sub-edgetype
gtlabel[,'subjects_wb'] <- sprintf('%s_%s', gtlabel$subjects_label, gtlabel$wb)

```

> Reduce grandtable to have consistent networks only & only 4 sessions (rows; using session 2-5)

```{r reduce_gt}
gt <- gt[,gtlabel$bignet=="Y"]
gtlabel <- gtlabel[gtlabel$bignet=="Y",]

gt <- gt[2:5,]

# check dim
dim(gt); dim(gtlabel)
```

> This is an SVD with centered columns and hierarchical (network edges -> subjects) MFA-normalized tables.

##### Data:

The data are from the morning scan club (MSC) resting-state data where the participants were each scanned 10 times (and we pick four of them). The data that are analyzed here are the z-transformed coefficients of correlation between regions. These regions can be categorized into different networks: 
  
```{r community_list, echo = FALSE, fig.height= 10, fig.width = 2}
# rename communities
#--- read the file with community information: label number & 
# community name & color & abbreviation for community name

colnames(CommName) <- c("Comm", "CommLabel","CommColor","CommLabel.short")
CommName[,'Community'] <- sapply(CommName$CommLabel, 
                                 FUN = function(x){strsplit(as.character(x), split = "_")[[1]][2]})
pander::pander(CommName[,c("Comm", "Community","CommLabel.short")])
```

```{r data_info}
# read parcel labels for each subject
parcel.list <- lapply(1:length(parcelfile2read), function(x){
  parcel <- read.table(paste0(parcel.comm.path, parcelfile2read[x]),sep = ",")
  getVoxDes(parcel,CommName)
})
names(parcel.list) <- subj.name
#-- Create colors for heatmap 
labelcol <- list()
textcol <- list()
for(i in 1:length(subj.name)){
  labelcol[[i]] <- parcel.list[[i]]$Comm.col$gc[order(rownames(parcel.list[[i]]$Comm.col$gc))]
  names(labelcol)[i] <- subj.name[i]
  
  textcol[[i]] <- rep("black", length(labelcol[[i]]))
  textcol[[i]][as(colorspace::hex2RGB(labelcol[[i]]), "polarLUV")@coords[,1] < 35] <- "white"  # Convert hex2RGB to lum
}
```

> The correlation matrices were turned into a rectangular matrix

##### Rectangular data:

+ Rows: `r nrow(gt)` sessions

+ Columns: Different edges (e.g, _within DMN_, _between DMN & CON_, _between DMN & FPN_, etc.) of different subjects

_Note: The data was transformed from the upper triangle of the correlation matrices. From the correlation matrix of each session, its upper triangle are reshape as a vector. These reshaped vectors of different sessions are then concatenated on the rows and those of different subjects are concatenated on the columns._

##### Method:

+ Centering: across sessions (rows) (i.e., the columns are centered)

+ Normalizing: hierarchical MFA normalized by network edges then subjects 

First we compute the weights that are used to MFA-normalized each subject table. These weights are computed as the inverse of the first singular value:
  
```{r preproc_step, include = FALSE, message=FALSE}
# Center Columns (across rows) + MFA normalize mini-block (Subjects)
cgt <- expo.scale(gt, center = T, scale = F)
cgt[is.nan(cgt)] <- 0   # replace NaN with zero 

# Different levels of tables
## First
subtab_i <-  list(gtlabel$subjects_edge_label, gtlabel$subjects_label)  # Use subjects_edge_label as mini table
n_subtable <- list(length(unique(subtab_i[[1]])), length(unique(subtab_i[[2]])))  # Number of mini tables
n_lv <- length(subtab_i)
sv <- list()
data2check <- list()

for (k in 1:n_lv){
  if (k == 1){
    mfa_preproc <- cgt
  }
  sv[[k]] <- matrix(NA, 1, n_subtable[[k]])
  colnames(sv[[k]]) <- unique(subtab_i[[k]])
  
  for(i in 1:n_subtable[[k]]){
    sv[[k]][i] <- (svd(mfa_preproc[,subtab_i[[k]]==unique(subtab_i[[k]])[i]])$d[1]) # singular value from svd 
    
    # mfa-normalization
    mfa_preproc[,subtab_i[[k]]==unique(subtab_i[[k]])[i]] <- mfa_preproc[,subtab_i[[k]]==unique(subtab_i[[k]])[i]]/sv[[k]]
    
    data2check[[k]] <- mfa_preproc
  }
}

# set the column names
gt_preproc <- mfa_preproc
gt_preproc[is.nan(gt_preproc)] <- 0   # replace NaN with zero 
colnames(gt_preproc) <- gtlabel$subjects_edge_label
dim(gt_preproc) # check dimension

# show the weights for each table
lapply(1:n_lv, function(x){1/sv[[x]]})
```

Then, the preprocessed data are decomposed by the SVD:
  
```{r svd, include = FALSE}
svd.res <- epPCA(gt_preproc,scale = FALSE, center = FALSE, graphs = FALSE)
```

##### Results:

###### Scree plot

First, the scree plot illustrates the eigen value with percentage of explained variance of each component. The results showed that there are three important components with the percentage of explained variance more than average (i.e., 1/10).

```{r scree, echo = FALSE}
PlotScree(ev = svd.res$ExPosition.Data$t,
          title = "Compromise: Explained variance per dimension")
```

###### Contributions

Before checking the factor scores, we first plot the contributions to check the importance of network edges. The important edges are defined as those that with significant mean contribution to both components 1 and 2.

We first compute the contribution and find the important edges and sessions:
  
```{r contribution}
#--- get the contribution of each component
cI <- svd.res$ExPosition.Data$ci
cJ <- svd.res$ExPosition.Data$cj

#--- get the sum of contribution for each edge
c_edge <- aggregate(cJ,list(edge = gtlabel$subjects_edge_label),sum)
rownames(c_edge) <- c_edge$edge
c_edge <- c_edge[,-1]
rownames(cI) <- c(1:nrow(gt))

## Find important sessions
#--- get the contribution for component 1 AND 2 by sum(SS from 1, SS from 2)/sum(eigs 1, eigs 2)
sesCtr12 <- (cI[,1]+cI[,2])/(svd.res$ExPosition.Data$eigs[1] + svd.res$ExPosition.Data$eigs[2])

#--- the important sessions are the ones that contribute more than or equal to the average
importantSes <- (sesCtr12 >= 1/length(sesCtr12))
importantSes1 <- (cI[,1] >= 1/length(cI[,1]))
importantSes2 <- (cI[,2] >= 1/length(cI[,2]))

#--- color for sessions
col4ImportantSes <- as.matrix(rep("mediumorchid4",nrow(cI)))  # get colors
col4NS <- 'gray48'                                            # set color for not significant edges to gray
col4ImportantSes[!importantSes] <- col4NS                     # replace them in the color vector

## Find important edges
#--- compute the sums of squares of each variable for each component
absCtrEdg <- as.matrix(c_edge) %*% diag(svd.res$ExPosition.Data$eigs)

#--- get the contribution for component 1 AND 2 by sum(SS from 1, SS from 2)/sum(eigs 1, eigs 2)
edgCtr12 <- (absCtrEdg[,1] + absCtrEdg[,2])/(svd.res$ExPosition.Data$eigs[1] + svd.res$ExPosition.Data$eigs[2])

#--- the important variables are the ones that contribute more than or equal to the average
importantEdg <- (edgCtr12 >= 1/length(edgCtr12))
importantEdg1 <- (cI[,1] >= 1/length(cJ[,1]))
importantEdg2 <- (cI[,2] >= 1/length(cJ[,2]))

#--- find the between/within description for each network edge
net.edge <- matrix(NA, nrow = nrow(c_edge),ncol = 1)
for (i in 1:nrow(c_edge)){
  edge2check <- rownames(c_edge)[i]
  net.edge[i,1] <- unique(gtlabel[which(gtlabel$subjects_edge_label == edge2check),"subjects_wb"])
}

#--- create color based on the between/within description for network edges
net.edge.col <- list(oc = as.matrix(plyr::mapvalues(net.edge,from = unique(net.edge), to = rep(cols25(10),each = 2))),
                     gc = as.matrix(rep(cols25(10),each = 2)))
rownames(net.edge.col$oc) <- rownames(c_edge)
rownames(net.edge.col$gc) <- unique(net.edge)

#--- color for networks
col4ImportantEdg <- net.edge.col$oc # get colors
col4NS <- 'gray90' # set color for not significant edges to gray
col4ImportantEdg[!importantEdg] <- col4NS # replace them in the color vector
```


Then the contributions are shown in plots

```{r plot_ci, echo=F, fig.show = 'hide'}
ciplot <- createFactorMap(cI,
                          axis1 = 1, axis2 = 2,
                          col.points = col4ImportantSes,
                          text.cex = 5,
                          cex = 3,
                          force = 0.5,
                          title = "Contibutions for sessions")
cjplot_all <- createFactorMap(c_edge,
                              axis1 = 1, axis2 = 2,
                              col.points = col4ImportantEdg,
                              text.cex = 2,
                              force = 0.5,
                              title = "Contibutions for all subject x edges")
cjplot_imp <- createFactorMap(c_edge[importantEdg,],
                              axis1 = 1, axis2 = 2,
                              col.points = col4ImportantEdg[importantEdg],
                              col.labels = col4ImportantEdg[importantEdg],
                              text.cex = 2,
                              force = 0.5,
                              title = "Significant contribution")
f.labels <- createxyLabels.gen(x_axis = 1, y_axis = 2,
                               lambda = svd.res$ExPosition.Data$eigs,
                               tau = svd.res$ExPosition.Data$t,
                               axisName = "Dimension ")
ciplot01 <- ciplot$zeMap + f.labels
cjplot01 <- cjplot_all$zeMap_background + cjplot_all$zeMap_dots + f.labels
cjplot02 <- cjplot_imp$zeMap_background + cjplot_imp$zeMap_dots + cjplot_imp$zeMap_text + f.labels
```

```{r grid_ciplot, echo=F, fig.height=12, fig.width=12}
gridExtra::grid.arrange(as.grob(cjplot01), as.grob(cjplot02), as.grob(ciplot01),ncol=2,
                        top = textGrob("Contribution plots",gp=gpar(fontsize=18,font=3)))
```

The contribution for each network edge is computed by dividing its total SS across region edges and dimensions (i.e., the cross product of contribution and eigenvalues) by the total eigenvalues of the two components.

###### Factor scores

First, we plot the factor scores for the 10 sessions

```{r plot_f_sess, echo = FALSE}
# Change column names for fi for later use
colnames(svd.res$ExPosition.Data$fi) <- sapply(c(1:ncol(svd.res$ExPosition.Data$fi)), 
                                               function(x) {sprintf("Dimension %s", x)})

# Plot factor scores
plot.f_sess <- createFactorMap(svd.res$ExPosition.Data$fi)
plot.f_sess$zeMap + f.labels
```

We can also plot the partial factor scores that show how each subject contribute to different sesssions.

```{r partial_f_sess}
# We can also compute the partial factor scores for each participant:
subj.table <- gtlabel$subjects_label
table2normalize <- subtab_i
n_subj <- length(unique(gtlabel$subjects_label))
n_table2normalize <- sapply(1:n_subj, function(x){
  length(unique(table2normalize[which(subj.table == unique(subj.table)[x])]))})

# compute partial factor scores: K x sv[1] x X_k x Q_k
pFi <- sapply(1:n_subj, function(x){
  # weighted by the inverse of "the # of tables contributed for each subject"
  (sum(n_table2normalize)/n_table2normalize[x])/(sv[[1]][x])*cgt[,which(subj.table == unique(subj.table)[x])] %*% (svd.res$ExPosition.Data$pdq$q[which(subj.table == unique(subj.table)[x]),])
}, simplify = "array")

# name the dimension of the array that stores partial F
dimnames(pFi) <- list(rownames(cgt),colnames(svd.res$ExPosition.Data$fi),unique(subj.table))

## Check barycentric
ch1 <- apply(pFi,c(1:2),mean)
ch2 <- cgt %*% (svd.res$ExPosition.Data$pdq$q)
```


```{r plot_pf_sess, echo = FALSE}
#  And plot them on the same factor map:
#find the constraints for the pF map
pF.constraints <- minmaxHelper4Partial(
  FactorScores = svd.res$ExPosition.Data$fi,
  partialFactorScores = pFi)
# plot again the factor map
plot.f_sess4pF <- createFactorMap(svd.res$ExPosition.Data$fi,
                                  constraints = pF.constraints) # with t(gt)

# select color for subjects (subtables)
plot.pf_sess <- createPartialFactorScoresMap(
  colors4Blocks = unique(net.edge.col$gc),
  factorScores = svd.res$ExPosition.Data$fi,
  partialFactorScores = pFi,
  axis1 = 1, axis2 = 2,
  names4Partial = subj.name,
  font.labels = "bold"
)

# add it to the factor map ** MYC this broke when there is 3 subjects, ask JC 20190410
plot.f_sess4pF$zeMap + f.labels + plot.pf_sess$mapColByBlocks
```

To have a clearer view of the factor scores for the subject x edges, we first compute the mean factor scores for the each network edge.

```{r mean_fj_bootstrap}
# Compute means of factor scores for different edges----
mean.fj <- getMeans(svd.res$ExPosition.Data$fj, gtlabel$subjects_edge_label) # with t(gt)
colnames(mean.fj) <- paste("Factor", 1:ncol(mean.fj))

tictoc::tic()
BootCube.Comm <- Boot4Mean(svd.res$ExPosition.Data$fj,
                           parallelize = TRUE,
                           design = gtlabel$subjects_edge_label,
                           niter = 100,
                           suppressProgressBar = TRUE)
tictoc::toc()

# compute mean factor scores for each edge and the partial factor scores of each subject for these factor scores
### use split string to separate the subject and edge labels (this is done at this step because we want to take the average across them after averaging across regions that belong to the same edge and subject)
mean.fj.label <- strsplit(sub('(^[^_]+)_(.*)$', '\\1 \\2', rownames(mean.fj)), ' ') %>% 
                    unlist %>% 
                    matrix(ncol = 2, byrow = T, dimnames = list(rownames(mean.fj),c("sub","edge"))) %>% 
                    data.frame

### compute means
mean.edge.fj <- getMeans(mean.fj, mean.fj.label$edge)

### create array for partial factor scores
edge.pF <- array(data = NA, 
                 dim = (c(nrow(mean.edge.fj), ncol(mean.fj), length(unique(mean.fj.label$sub)))), 
                 dimnames = list(rownames(mean.edge.fj), colnames(mean.fj), unique(mean.fj.label$sub)))

### fill the array of partial factor scores
n.edges <- dim(edge.pF)[1]

for (i in 1:length(subj.name)){
  for (j in 1:n.edges){
    tbname <- subj.name[i]
    rwname <- rownames(edge.pF)[j]
    edge.pF[rwname,,tbname] <- as.matrix(mean.fj[which(mean.fj.label$sub == tbname & mean.fj.label$edge == rwname),])
  }
}

tictoc::tic()
BootCube.Comm.edge <- Boot4Mean(mean.fj,
                                parallelize = TRUE,
                                design = mean.fj.label$edge,
                                niter = 100,
                                suppressProgressBar = TRUE)
tictoc::toc()

# Compute means of factor scores for different types of edges
mean.fj.bw <- getMeans(svd.res$ExPosition.Data$fj, gtlabel$subjects_wb) # with t(gt)
colnames(mean.fj.bw) <- paste("Factor", 1:ncol(mean.fj.bw))

tictoc::tic()
BootCube.Comm.bw <- Boot4Mean(svd.res$ExPosition.Data$fj,
                              parallelize = T,
                              design = gtlabel$subjects_wb,
                              niter = 100,
                              suppressProgressBar = TRUE)
tictoc::toc()
```

Next, we plot the factor scores for the subject x edges (a mess): Dim 1 & 2
```{r plot_f_edge, echo=FALSE, fig.show = 'hide'}
# plot all factor scores
plot.f_edge <- createFactorMap(mean.fj, axis1 = 1, axis2 = 2,
                               col.points = net.edge.col$oc,
                               text.cex = 2,
                               force = 0.5,
                               title = "All factor scores - colored by subject_x_edge types")
f_netedge_plot01 <- plot.f_edge$zeMap_background + plot.f_edge$zeMap_dots + f.labels
# plot the significantly contributed factor scores
plot.f_edge_imp <- createFactorMap(mean.fj, axis1 = 1, axis2 = 2,
                                   col.points = col4ImportantEdg,
                                   col.labels = col4ImportantEdg,
                                   text.cex = 2,
                                   force = 0.5,
                                   title = "Significantly contributed factor scores - colored by subject_x_edge types")
f_netedge_plot02 <- plot.f_edge_imp$zeMap_background + plot.f_edge_imp$zeMap_dots + f.labels
# plot only the significant network edges
plot.f_impedge <- createFactorMap(mean.fj[importantEdg,], axis1 = 1, axis2 = 2,
                                  col.points = col4ImportantEdg[importantEdg,],
                                  col.labels = col4ImportantEdg[importantEdg,],
                                  constraints = plot.f_edge_imp$constraints,
                                  text.cex = 2,
                                  force = 0.5,
                                  title = "Significantly contributed factor scores\n(colored by subject_x_edge types)")
f_netedge_plot03 <- plot.f_impedge$zeMap + f.labels
# plot mean factor scores of subject x edge type
plot.f_bw_imp <- createFactorMap(mean.fj.bw, axis1 = 1, axis2 = 2,
                                 col.points = net.edge.col$gc[rownames(mean.fj.bw),],
                                 col.labels = net.edge.col$gc[rownames(mean.fj.bw),],
                                 text.cex = 3,
                                 force = 0.5,
                                 title = "Mean factor scores for subject_x_edge types")
f_netedge_plot04 <- plot.f_bw_imp$zeMap_background + plot.f_bw_imp$zeMap_dots + plot.f_bw_imp$zeMap_text + f.labels
# plot mean factor scores of network edges
### plot the mean factor scores for network edges
plot.f_edge4pF <- createFactorMap(mean.edge.fj,
                                  constraints = minmaxHelper4Partial(mean.edge.fj,edge.pF),
                                  text.cex = 3) # with t(gt)
# partial factor scores for for subjects (subtables)
plot.pf_edge <- createPartialFactorScoresMap(
  factorScores = mean.edge.fj,
  partialFactorScores = edge.pF,
  axis1 = 1, axis2 = 2,
  names4Partial = subj.name,
  font.labels = "bold"
)
f_netedge_plot05 <- plot.f_edge4pF$zeMap + f.labels + plot.pf_edge$mapColByBlocks
```


```{r grid_f_netedge_plot, echo=F, fig.height=12, fig.width=12}
gridExtra::grid.arrange(as.grob(f_netedge_plot01), 
                        as.grob(f_netedge_plot02), 
                        as.grob(f_netedge_plot03), 
                        as.grob(f_netedge_plot04), 
                        as.grob(f_netedge_plot05), 
                        nrow=2,
                        top = textGrob("Mean factor scores for edges",gp=gpar(fontsize=18,font=3)))
```

Note that a network edge with its region edges significantly contribute to the components both positively and negatively results in a significant mean factor score that is close to the origin. Also, a network edge with only few region edges will lead to a small total SS as compared to the total eigenvalues; this type of network edge might not be significant even when being far away from the origin. (This is shown in the chunk named `checkCtr` which is hidden/commented in the .rmd.)

We can also add boostrap intervals for the factor scores
```{r CI_plot, echo = FALSE, fig.show='hide', message= FALSE}
# plot the only significantly contributed factor scores
# get the bootstrap data for each network edge
getBoot2plot_edge <- BootCube.Comm$BootCube[importantEdg,c(1,2),]

# plot the CI ellipses
f_impedge.CI <- MakeCIEllipses(getBoot2plot_edge,
                               names.of.factors = c(sprintf("Factor %s", 1),sprintf("Factor %s", 2)),
                               col = col4ImportantEdg[importantEdg,],
                               p.level = .95)

# create plot
f_CInetedge_plot01 <- plot.f_impedge$zeMap_background + 
                        plot.f_impedge$zeMap_dots + 
                        f.labels

f_CInetedge_plot02 <- plot.f_impedge$zeMap_background + 
                        plot.f_impedge$zeMap_dots + f_impedge.CI + 
                        f.labels

# get the bootstrap data for each type of network edges
getBoot2plot_edge_bw <- BootCube.Comm.bw$BootCube[,c(1,2),]

# plot the CI ellipses
plot.CI.f_bw <- MakeCIEllipses(getBoot2plot_edge_bw,
                               names.of.factors = c(sprintf("Factor %s", 1),sprintf("Factor %s", 2)),
                               col = net.edge.col$gc[rownames(getBoot2plot_edge_bw),],
                               p.level = .95)
# create plot
f_CInetedge_plot03 <- plot.f_bw_imp$zeMap + 
                        plot.CI.f_bw + 
                        f.labels
```

```{r grid_f_netedgeCI_plot, echo=F, fig.height=12, fig.width=12, message=FALSE}
gridExtra::grid.arrange(as.grob(f_CInetedge_plot01), 
                        as.grob(f_CInetedge_plot02), 
                        as.grob(f_CInetedge_plot03),
                        ncol=2,
                        top = textGrob("Mean factor scores with CIs for significantly contributed edges",
                                       gp=gpar(fontsize=18,font=3)))
```

We can also show the factor scores for network edges as square matrix of each subject.

```{r squaremat_fi, echo=F, fig.show = 'hide'}
fj1_sqmat <- list()
fj2_sqmat <- list()
for(i in 1:length(subj.name)){
  fj1_sqmat[[i]] <- vec2sqmat(svd.res$ExPosition.Data$fj[gtlabel$subjects_label==subj.name[i],1]) 
  fj2_sqmat[[i]] <- vec2sqmat(svd.res$ExPosition.Data$fj[gtlabel$subjects_label==subj.name[i],2])   
}

## Set heat limit
quantlim <- quantile(unlist(fj1_sqmat), c(.15,.85)) # expanded limit for HMFA
heatlim <- c(-round(min(min(abs(quantlim))), digits=5), # limit equal on pos/neg, round 3digits
             round(min(min(abs(quantlim))), digits=5))
heat_fj1 <- list()
heat_fj2 <- list()
for(i in 1:length(subj.name)){
  heat_fj1[[i]] <- superheat(as.matrix(fj1_sqmat[[i]]), y.axis.reverse = T,
                             membership.rows = parcel.list[[i]]$vox.des$Comm.rcd,
                             membership.cols = parcel.list[[i]]$vox.des$Comm.rcd,                    
                             left.label.col = labelcol[[i]],
                             bottom.label.col = labelcol[[i]],
                             left.label.size = 0.08,
                             bottom.label.size = 0.05,
                             extreme.values.na = FALSE,
                             heat.lim = heatlim,
                             heat.pal = kovesi.diverging_bwr_40_95_c42(200),
                             heat.pal.values = c(0,0.35,0.5,0.65,1),
                             left.label.text.size = 3,
                             bottom.label.text.size = 2,
                             left.label.text.col = textcol[[i]], 
                             bottom.label.text.col = textcol[[i]], 
                             title=sprintf("%s, dim1",subj.name[i]))$plot
  
  heat_fj2[[i]]  <- superheat(fj2_sqmat[[i]], y.axis.reverse = T,
                              membership.rows = parcel.list[[i]]$vox.des$Comm.rcd,
                              membership.cols = parcel.list[[i]]$vox.des$Comm.rcd,
                              left.label.col = labelcol[[i]],
                              bottom.label.col = labelcol[[i]],
                              left.label.size = 0.08,
                              bottom.label.size = 0.05,
                              extreme.values.na = FALSE,
                              heat.lim = heatlim,
                              heat.pal = kovesi.diverging_bwr_40_95_c42(200),
                              heat.pal.values = c(0,0.35,0.5,0.65,1),
                              left.label.text.size = 3,
                              bottom.label.text.size = 2,
                              left.label.text.col = textcol[[i]],
                              bottom.label.text.col = textcol[[i]],
                              title=sprintf("%s, dim2",subj.name[i]))$plot
}
```

Node x Node Matrix of Factor Score: Dim 1 & Dim 2
```{r grid_heat_fi, echo=F, fig.height=20, fig.width=40}
print("Dimension 1")
do.call(grid.arrange, c(heat_fj1, ncol=(length(subj.name)/2)))
print("Dimension 2")
do.call(grid.arrange, c(heat_fj2, ncol=(length(subj.name)/2)))
```

Factor score (Dim 1) in square matrix that have significant contribution only
```{r, squaremat_sigfj1, echo=F, fig.show = 'hide'}
fj_sig <- svd.res$ExPosition.Data$fj
fj_sig[!importantEdg1] <- 0
fj1_sig_sqmat <- list()
for(i in 1:length(subj.name)){
  fj1_sig_sqmat[[i]] <- vec2sqmat(fj_sig[gtlabel$subjects_label==subj.name[i],1])
}
heat_sigfj1 <- list()
for(i in 1:length(subj.name)){
  heat_sigfj1[[i]] <- superheat(fj1_sig_sqmat[[i]], y.axis.reverse = T,
                                membership.rows = parcel.list[[i]]$vox.des$Comm.rcd,
                                membership.cols = parcel.list[[i]]$vox.des$Comm.rcd,                    
                                left.label.col = labelcol[[i]],
                                bottom.label.col = labelcol[[i]],
                                left.label.size = 0.08,
                                bottom.label.size = 0.05,
                                extreme.values.na = FALSE,
                                heat.lim = heatlim,
                                heat.pal = kovesi.diverging_bwr_40_95_c42(200),
                                heat.pal.values = c(0,0.35,0.5,0.65,1),
                                left.label.text.size = 3,
                                bottom.label.text.size = 2,
                                left.label.text.col = textcol[[i]], 
                                bottom.label.text.col = textcol[[i]], 
                                title=sprintf("%s: significant contribution",subj.name[i]))$plot
}
```

Node x Node Matrix of Factor Score w/ Sig Contribution: Dim 1
```{r, grid_heat_sigfj1, echo=F, fig.height=20, fig.width=40}
do.call(grid.arrange, c(heat_sigfj1, ncol=(length(subj.name)/2)))
```

Smoothed Sig Factor Score (Dim 1)
```{r, sm_squaremat_sigfj1, echo=F, fig.show = 'hide'}
#--- the important variables are the ones that contribute more than or equal to the average
sm_heat_sigfj1 <- list()
for(i in 1:length(subj.name)){
  sm_heat_sigfj1[[i]] <- superheat(fj1_sig_sqmat[[i]], y.axis.reverse = T,
                                   smooth.heat = T, smooth.heat.type = "mean",
                                   membership.rows = parcel.list[[i]]$vox.des$Comm.rcd,
                                   membership.cols = parcel.list[[i]]$vox.des$Comm.rcd,                    
                                   left.label.col = labelcol[[i]],
                                   bottom.label.col = labelcol[[i]],
                                   left.label.size = 0.08,
                                   bottom.label.size = 0.05,
                                   extreme.values.na = FALSE,
                                   heat.lim = heatlim,
                                   heat.pal = kovesi.diverging_bwr_40_95_c42(200),
                                   heat.pal.values = c(0,0.35,0.5,0.65,1),
                                   left.label.text.size = 3,
                                   bottom.label.text.size = 2,
                                   left.label.text.col = textcol[[i]], 
                                   bottom.label.text.col = textcol[[i]], 
                                   title=sprintf("%s: significant contribution (mean-smooth)",subj.name[i]))$plot
}
```

Smoothed Node x Node Matrix of Factor Score w/ Sig Contribution: Dim 1
```{r, grid_smheat_sigfj1, echo=F, fig.height=20, fig.width=40}
do.call(grid.arrange, c(sm_heat_sigfj1, ncol=(length(subj.name)/2)))
```

Factor score (Dim 2) in square matrix that have significant contribution only
```{r, squaremat_sigfj2, echo=F, fig.show = 'hide'}
fj2_sig_sqmat <- list()
for(i in 1:length(subj.name)){
  fj2_sig_sqmat[[i]] <- vec2sqmat(fj_sig[gtlabel$subjects_label==subj.name[i],2])
}
heat_sigfj2 <- list()
for(i in 1:length(subj.name)){
  heat_sigfj2[[i]] <- superheat(fj2_sig_sqmat[[i]], y.axis.reverse = T,
                                membership.rows = parcel.list[[i]]$vox.des$Comm.rcd,
                                membership.cols = parcel.list[[i]]$vox.des$Comm.rcd,                    
                                left.label.col = labelcol[[i]],
                                bottom.label.col = labelcol[[i]],
                                left.label.size = 0.08,
                                bottom.label.size = 0.05,
                                extreme.values.na = FALSE,
                                heat.lim = heatlim,
                                heat.pal = kovesi.diverging_bwr_40_95_c42(200),
                                heat.pal.values = c(0,0.35,0.5,0.65,1),
                                left.label.text.size = 3,
                                bottom.label.text.size = 2,
                                left.label.text.col = textcol[[i]], 
                                bottom.label.text.col = textcol[[i]], 
                                title=sprintf("%s: significant contribution",subj.name[i]))$plot
}
```

Node x Node Matrix of Factor Score w/ Sig Contribution: Dim 2
```{r, grid_heat_sigfj2, echo=F, fig.height=20, fig.width=40}
do.call(grid.arrange, c(heat_sigfj2, ncol=(length(subj.name)/2)))
```

Smoothed Sig Factor Score (Dim 2)
```{r, sm_squaremat_sigfj2, echo=F, fig.show = 'hide'}
#--- the important variables are the ones that contribute more than or equal to the average
sm_heat_sigfj2 <- list()
for(i in 1:length(subj.name)){
  sm_heat_sigfj2[[i]] <- superheat(fj2_sig_sqmat[[i]], y.axis.reverse = T,
                                   smooth.heat = T, smooth.heat.type = "mean",
                                   membership.rows = parcel.list[[i]]$vox.des$Comm.rcd,
                                   membership.cols = parcel.list[[i]]$vox.des$Comm.rcd,                    
                                   left.label.col = labelcol[[i]],
                                   bottom.label.col = labelcol[[i]],
                                   left.label.size = 0.08,
                                   bottom.label.size = 0.05,
                                   extreme.values.na = FALSE,
                                   heat.lim = heatlim,
                                   heat.pal = kovesi.diverging_bwr_40_95_c42(200),
                                   heat.pal.values = c(0,0.35,0.5,0.65,1),
                                   left.label.text.size = 3,
                                   bottom.label.text.size = 2,
                                   left.label.text.col = textcol[[i]], 
                                   bottom.label.text.col = textcol[[i]], 
                                   title=sprintf("%s: significant contribution (mean-smooth)",subj.name[i]))$plot
}
```

Smoothed Node x Node Matrix of Factor Score w/ Sig Contribution: Dim 2
```{r, grid_smheat_sigfj2, echo=F, fig.height=20, fig.width=40}
do.call(grid.arrange, c(sm_heat_sigfj2, ncol=(length(subj.name)/2)))
```



