---
title: "Demonstrating STATIS normalization on a correlation matrix"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,collapse=TRUE, comment="##")
```

## Idea
Before starting this project, we were not sure how we should normalize our data to control for counding factors (e.g., voxel size and network size) and keep important signals. (But what is really the important information?) Since the correlation matrix we work on resemble a distance matrix. We came up with the idea of matrix preprocessing steps similar to that of DiSTATIS (i.e., STATIS for distance matrices). This type of preprocessing consists of two steps:

* Double-center
* Normalized by the first eigenvalue of the double-centered matrix

## Objectives
Here, we illustrate how data are changed along these steps and how the final singular value  decomposition (SVD) results are affected.

## Start with an example data

```{r cars, echo = FALSE, include = FALSE}
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
suppressMessages(library(PTCA4CATA))
suppressMessages(library(ExPosition))
suppressMessages(library(pheatmap))
```

### Fake data
We start with a fake data with blocks of correlation.

```{r pressure, echo = FALSE}
X <- as.matrix(read.csv("FakeData.csv"))
head(X)
```

### Fake correlation
Then, compute its correlation matrix.

```{r correlation}
### fake correlation:
# changed to all positive values
cor.X <- abs(cor(X))
dim(cor.X)
```

Setting up colors for plotting
```{r color_setting}
group.col <- RColorBrewer::brewer.pal(5,"Set1")[c(rep(x=1,8),rep(x=2,9),rep(x=3,9),rep(x=4,8),rep(x=5,10))]
group.des <- c(rep("E",8),rep("A",9),rep("C",9),rep("N",8),rep("O",10))
group.des.nominal <- makeNominalData(as.matrix(group.des))
group.des.nomnorm <- group.des.nominal/c(rep(8,8),rep(9,9),rep(9,9),rep(8,8),rep(10,10))
group.des.df <- data.frame(group = factor(group.des),row.names = colnames(X))
group.des.col <- list(group = c(E = RColorBrewer::brewer.pal(5,"Set1")[1],
                                A = RColorBrewer::brewer.pal(5,"Set1")[2],
                                C = RColorBrewer::brewer.pal(5,"Set1")[3],
                                N = RColorBrewer::brewer.pal(5,"Set1")[4],
                                O = RColorBrewer::brewer.pal(5,"Set1")[5]))
value.col <- colorRamps::blue2red(100)
```


Plot the heatmap:

```{r show_cor, echo = FALSE}
pheatmap(cor.X, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 7,cellheight = 7,
         annotation_col = group.des.df,
         annotation_row = group.des.df,
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-1,1,by = 0.02))
```

## STATIS-like normalization

### STEP 1 : Double centering
Centering across columns and rows so that each row and column has a mean of 0.

```{r double_center}
# center columns and rows
corX.c <- cor.X %>% scale(scale = FALSE) %>% t %>% scale(scale = FALSE)
```

Plot the heatmap:

```{r show_center, echo = FALSE}
pheatmap(corX.c, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 7,cellheight = 7,
         annotation_col = group.des.df,
         annotation_row = group.des.df,
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-1,1,by = 0.02))
```

### STEP 1.5: Eigen decomposition
Perform an eigen decomposition and record the eigenvalues.

```{r eig}
# get the first eigenvalue
eig.res.corX <-eigen(corX.c)
Lambda.corX <- eig.res.corX$`values`
Q.corX <- eig.res.corX$vectors
Q1 <- as.matrix(diag(Q.corX[,1]))
rownames(Q1) <- colnames(X)
colnames(Q1) <- colnames(X)
```

Plot eigen vectors:

```{r show_eig, echo = FALSE}
pheatmap(Q1, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 7,cellheight = 7,
         annotation_col = group.des.df,
         annotation_row = group.des.df,
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         )
```

### STEP 2 : Devided the double-centered matrix by the first eigenvalue
```{r d_eig}
end.X <- corX.c/Lambda.corX[1]
```

Plot final result:

```{r show_endX, echo = FALSE}
pheatmap(end.X, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 7,cellheight = 7,
         annotation_col = group.des.df,
         annotation_row = group.des.df,
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-0.2,0.2,by = 0.004))
```

With its sums of squares:

```{r ss_endX, echo = FALSE}
ss_endX <- t(group.des.nominal) %*% end.X^2 %*% group.des.nominal
rownames(ss_endX) <- c("E","A","C","N","O")
colnames(ss_endX) <- c("E","A","C","N","O")
ss_endX
pheatmap(ss_endX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-0.1,0.1,by = 0.002))
```

With its normalized sums of squares:

```{r NormSS_endX,echo = FALSE}
NormSS_endX <- t(group.des.nomnorm) %*% end.X^2 %*% group.des.nomnorm
rownames(NormSS_endX) <- c("E","A","C","N","O")
colnames(NormSS_endX) <- c("E","A","C","N","O")
NormSS_endX
pheatmap(NormSS_endX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-0.002,0.002,by = 0.00004))
```

With its block means:

```{r mean_endX, echo = FALSE}
mean_endX <- t(group.des.nomnorm) %*% end.X %*% group.des.nomnorm
rownames(mean_endX) <- c("E","A","C","N","O")
colnames(mean_endX) <- c("E","A","C","N","O")
mean_endX
pheatmap(mean_endX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-0.03,0.03,by = 0.0006))

```

Plot the heatmap of the original matrix again to compare:

```{r show_cor2, echo = FALSE}
pheatmap(cor.X, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 7,cellheight = 7,
         annotation_col = group.des.df,
         annotation_row = group.des.df,
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-1,1,by = 0.02))
```

With its sums of squares:

```{r ss_corX,echo = FALSE}
ss_corX <- t(group.des.nominal) %*% cor.X^2 %*% group.des.nominal
rownames(ss_corX) <- c("E","A","C","N","O")
colnames(ss_corX) <- c("E","A","C","N","O")
ss_corX
pheatmap(ss_corX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-6,6,by = 0.12))

```

With its normalized sums of squares:

```{r NormSS_corX,echo = FALSE}
NormSS_corX <- t(group.des.nomnorm) %*% cor.X^2 %*% group.des.nomnorm
rownames(NormSS_corX) <- c("E","A","C","N","O")
colnames(NormSS_corX) <- c("E","A","C","N","O")
NormSS_corX
pheatmap(NormSS_corX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-0.1,0.1,by = 0.002))

```

With its block means:

```{r mean_corX,echo = FALSE}
mean_corX <- t(group.des.nomnorm) %*% cor.X %*% group.des.nomnorm
rownames(mean_corX) <- c("E","A","C","N","O")
colnames(mean_corX) <- c("E","A","C","N","O")
mean_corX
pheatmap(mean_corX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-0.2,0.2,by = 0.004))

```

## Try PCA
Let's see how the PCA results are changed after the STATIS-like normalization.

```{r pca_set}
# Group design
group.des <- c(rep(x=1,8),rep(x=2,9),rep(x=3,9),rep(x=4,8),rep(x=5,10))
# PCA with original correlation matrix
corX.pca.res <- epPCA(cor.X, center = FALSE, scale = FALSE, DESIGN = group.des, make_design_nominal = TRUE, graphs = FALSE)
# PCA with the STATIS-normalized matrix
endX.pca.res <- epPCA(end.X, center = FALSE, scale = FALSE, DESIGN = group.des, make_design_nominal = TRUE, graphs = FALSE)

```

#### PCA results with original correlation matrix
```{r pcaRes_corX, echo = FALSE}
par(mfrow=c(1,2))
corX.p <- createFactorMap(corX.pca.res$ExPosition.Data$fi,
                          col.points = group.col,
                          col.labels = group.col,
                          display.points = TRUE,
                          display.labels = TRUE
)
labels4corX <- createxyLabels.gen(
  lambda = corX.pca.res$ExPosition.Data$eigs ,
  tau = corX.pca.res$ExPosition.Data$t,
  axisName = "Dimension ")
print(corX.p$zeMap + labels4corX)
```

#### PCA results with STATIS-normalized matrix
```{r pcaRes_endX, echo = FALSE}
endX.p <- createFactorMap(endX.pca.res$ExPosition.Data$fi,
                          col.points = group.col,
                          col.labels = group.col,
                          display.points = TRUE,
                          display.labels = TRUE
)
labels4endX <- createxyLabels.gen(
  lambda = endX.pca.res$ExPosition.Data$eigs ,
  tau = endX.pca.res$ExPosition.Data$t,
  axisName = "Dimension ")
print(endX.p$zeMap + labels4endX)
```


