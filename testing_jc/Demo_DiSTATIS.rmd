---
title: "Demo_DiSTATIS"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,collapse=TRUE, comment="##")
```

## Idea
To test how different normalization works on a cube, we first run a DiSTATIS on this cube to get the result that we can compare the results from other techniques to.

## Objectives
Here, we illustrate the DiSTATIS results.

```{r cars, echo = FALSE, include = FALSE}
suppressMessages(library(psych))
suppressMessages(library(DistatisR))
suppressMessages(library(tidyr))
suppressMessages(library(magrittr))
suppressMessages(library(DistatisR))
suppressMessages(library(PTCA4CATA))
suppressMessages(library(ExPosition))
suppressMessages(library(InPosition))
suppressMessages(library(superheat))
suppressMessages(library(gridExtra))
suppressMessages(library(ggplotify))
suppressMessages(library(grid))
```


## Read data

```{r data, echo = FALSE, include = FALSE}
zmat.path <- "../data/zmat"
load(paste0(zmat.path,"/sub-MSC01_zcube_rcube.RData"))
# read parcel labels
parcel.comm.path <- "../data/parcel_community"
vox.des <- read.table(paste0(parcel.comm.path,"/sub-MSC01_node_parcel_comm.txt"),sep = ",")
colnames(vox.des) <- c("NodeID","VertexID","Comm")
# rename communities
CommName <- read.csv(paste0(parcel.comm.path,"/systemlabel.txt"),sep = ",",header = FALSE)
colnames(CommName) <- c("Comm","CommLabel","CommColor","CommLabel.short")
for(i in 1:nrow(CommName)){
  vox.des$Comm.recode[vox.des$Comm==CommName$Comm[i]] <- as.character(CommName$CommLabel[i])
  vox.des$Comm.Col[vox.des$Comm==CommName$Comm[i]] <- as.character(CommName$CommColor[i])
  vox.des$Comm.rcd[vox.des$Comm==CommName$Comm[i]] <- as.character(CommName$CommLabel.short[i])
}
```

This is a data cube of correlation: ROIs x ROIs x 10 sessions

```{r check, echo = TRUE, include = TRUE}
## Exclude negative correlations
cubes$rcube[cubes$rcube < 0] <- 0
# Dimensions
dim(cubes$rcube)
```

This correlation data are then transformed into distances (for DiSTATIS)

```{r dist}
dcube <- cor2dist(cubes$rcube)
# Dimension
dim(dcube)
```

Get community information and create colors for different communities
```{r comm}
Comm.col <- list(oc = as.matrix(vox.des$Comm.Col), gc = as.matrix(CommName$CommColor))
rownames(Comm.col$oc) <- vox.des$NodeID
rownames(Comm.col$gc) <- CommName$CommLabel.short
```

## Check data with heatmap for the 1st session
```{r show_heatmap, echo = FALSE, fig.height= 16, fig.width = 16}
superheat(cubes$rcube[,,1],
          membership.cols = vox.des$Comm.rcd,
          membership.rows = vox.des$Comm.rcd,
          clustering.method = NULL,
          heat.col.scheme = "viridis",
          left.label.size = 0.08,
          bottom.label.size = 0.05,
          y.axis.reverse = TRUE,
          left.label.col = Comm.col$gc[order(rownames(Comm.col$gc))], # order by community name
          bottom.label.col = Comm.col$gc[order(rownames(Comm.col$gc))],
          left.label.text.size = c(rep(6,4), rep(3,3),6,3,  rep(6,2),3,rep(6,5),3,3),
          bottom.label.text.size = 2,
          left.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
          bottom.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
          left.label.text.alignment = "left",
          title = "Correlation matric of the 1st session"
)
```

## Run DiSTATIS
```{r distatis}
# DiSTATIS
distatis.res <- distatis(dcube)
```

## Plot results

### Rv space

#### Eigenvalues

```{r Rv.scree, echo = FALSE}
PlotScree(ev = distatis.res$res4Cmat$eigValues,
          title = "RV-map: Expained variance per dimension")
```

#### Factor scores

```{r Rv.f}
### Rv factor scores
rv.graph <- createFactorMap(distatis.res$res4Cmat$G,
                axis1 = 1, axis2 = 2)
### Dimension labels for the Rv map
rv.labels <- createxyLabels.gen(lambda = distatis.res$res4Cmat$eigValues,
                                tau = distatis.res$res4Cmat$tau,
                                axisName = "Dimension ")
### Show plot
Rvmap <- rv.graph$zeMap + rv.labels
print(Rvmap)
```

### Compromise space

#### Eigenvalues

```{r scree, echo = FALSE}
PlotScree(ev = distatis.res$res4Splus$eigValues,
          title = "Compromise: Explained variance per dimension")
```

Set the components of interest
```{r set.coi}
x_cp <- 1
y_cp <- 2
```

#### Factor scores

```{r f, echo = FALSE}
f.graph <- createFactorMap(distatis.res$res4Splus$F,
                           axis1 = x_cp, axis2 = y_cp,
                           title = "Compromise - Factor scores (nodes): cp 1 & 2",
                           col.points = Comm.col$oc,
                           alpha.points = .4, cex = 3)
f.graph.23 <- createFactorMap(distatis.res$res4Splus$F,
                           axis1 = 2, axis2 = 3,
                           title = "Compromise - Factor scores (nodes): cp 2 & 3",
                           col.points = Comm.col$oc,
                           alpha.points = .4, cex = 3)
f.labels <- createxyLabels.gen(x_axis = x_cp, y_axis = y_cp,
                               lambda = distatis.res$res4Splus$eigValues,
                               tau = distatis.res$res4Splus$tau,
                               axisName = "Dimension ")
f.labels.23 <- createxyLabels.gen(x_axis = 2, y_axis = 3,
                               lambda = distatis.res$res4Splus$eigValues,
                               tau = distatis.res$res4Splus$tau,
                               axisName = "Dimension ")
# Show plot
f01.Fi.noLabel <- f.graph$zeMap_background + f.graph$zeMap_dots + f.labels
f02.Fi.noLabel <- f.graph.23$zeMap_background + f.graph.23$zeMap_dots + f.labels.23
```

```{r plot_fig_f, echo=F, fig.height=8, fig.width= 16}
gridExtra::grid.arrange(as.grob(f01.Fi.noLabel), as.grob(f02.Fi.noLabel), ncol=2)
```

### Now plot the compromise space with means, confidence intervals, and tolerance intervals

#### Compute means for each network
```{r com.mean}
BootCube.Comm <- Boot4Mean(distatis.res$res4Splus$F,
                         design = vox.des$Comm.rcd,
                         niter = 100,
                         suppressProgressBar = TRUE)
```

#### Plot

```{r makefig, echo = FALSE}
### Plot means
f.mean.graph <- createFactorMap(BootCube.Comm$GroupMeans,
                                axis1 = x_cp, axis2 = y_cp,
                                title = "Compromise - Factor scores with means of networks: cp 1 & 2",
                                col.points = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                constraints = f.graph$constraints,
                                col.labels = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                alpha.points = .8,
                                pch = 15,
                                cex = 5)
### Plot means with its own constraints
f.mean.graph.owncon <- createFactorMap(BootCube.Comm$GroupMeans,
                                axis1 = x_cp, axis2 = y_cp,
                                title = "Compromise - Factor scores with means of networks: cp 1 & 2",
                                col.points = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                col.labels = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                alpha.points = .8,
                                pch = 15,
                                cex = 5)
### Plot bootstrapped confidence intervals for means
f.CI.graph <- MakeCIEllipses(BootCube.Comm$BootCube[,c(x_cp,y_cp),],
                                    names.of.factors = c(sprintf("Factor %s",x_cp),sprintf("Factor %s",y_cp)),
                                    col = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                    p.level = .95)
### Plot tolerance intervals of each community
f.TI.graph <- MakeToleranceIntervals(distatis.res$res4Splus$F,
                                     axis1 = x_cp, axis2 = y_cp,
                                     design = vox.des$Comm,
                                     names.of.factors = c("Dim1", "Dim2"),
                                     col = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                     line.size = .50,
                                     line.type = 3,
                                     alpha.ellipse = .2,
                                     alpha.line = .4,
                                     p.level =.95)
# With TI only
f01b.Fi.Ti <- f.graph$zeMap_background + f.TI.graph + f.graph$zeMap_dots + f.labels
# With CI and TI
f01c.Fi.CiTiMean <- f.graph$zeMap_background + f.TI.graph + f.graph$zeMap_dots + f.CI.graph + f.mean.graph$zeMap_dots + f.mean.graph$zeMap_text + f.labels
# CI only
f01d.Fi.CiMean <- f.mean.graph.owncon$zeMap_background + f.mean.graph.owncon$zeMap_dots + f.CI.graph + f.labels + f.mean.graph.owncon$zeMap_text
```

```{r makefig.cp23, echo = FALSE, include = FALSE}
### Plot means
f.mean.graph.23 <- createFactorMap(BootCube.Comm$GroupMeans,
                                axis1 = 2, axis2 = 3,
                                title = "Compromise - Factor scores with means of networks: cp 2 & 3",
                                col.points = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                constraints = f.graph$constraints,
                                col.labels = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                alpha.points = .8,
                                pch = 15,
                                cex = 5)
### Plot means with its own constraints
f.mean.graph.owncon.23 <- createFactorMap(BootCube.Comm$GroupMeans,
                                axis1 = 2, axis2 = 3,
                                title = "Compromise - Factor scores with means of networks: cp 2 & 3",
                                col.points = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                col.labels = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                alpha.points = .8,
                                pch = 15,
                                cex = 5)
### Plot bootstrapped confidence intervals for means
f.CI.graph.23 <- MakeCIEllipses(BootCube.Comm$BootCube[,c(2,3),],
                                    names.of.factors = c(sprintf("Factor %s",2),sprintf("Factor %s",3)),
                                    col = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                    p.level = .95)
# With mean
f02b.Fi.Mean <- f.graph.23$zeMap_background + f.graph.23$zeMap_dots + f.CI.graph.23 + f.mean.graph.23$zeMap_dots + f.mean.graph.23$zeMap_text + f.labels.23

# With CI
f02c.Fi.CiMean <- f.mean.graph.owncon.23$zeMap_background + f.mean.graph.owncon.23$zeMap_dots + f.CI.graph.23 + f.labels.23 + f.mean.graph.owncon.23$zeMap_text
```

##### All heat maps and Rv
```{r all_hmap, echo = FALSE, fig.show = 'hide'}
for(session.count in 1:dim(cubes$rcube)[3]){
  hmap.name <- sprintf("hmap%s",session.count)
  assign(hmap.name, superheat(cubes$rcube[,,session.count],
                              membership.cols = vox.des$Comm.rcd,
                              membership.rows = vox.des$Comm.rcd,
                              clustering.method = NULL,
                              heat.col.scheme = "viridis",
                              left.label.size = 0.08,
                              bottom.label.size = 0.05,
                              y.axis.reverse = TRUE,
                              left.label.col = Comm.col$gc[order(rownames(Comm.col$gc))], # order by community name
                              bottom.label.col = Comm.col$gc[order(rownames(Comm.col$gc))],
                              left.label.text.size = 3,
                              bottom.label.text.size = 2,
                              left.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
                              bottom.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
                              left.label.text.alignment = "left",
                              title = sprintf("Correlation matrix of #%s session",session.count)
  )
  )
}
```
Rv factor scores:

```{r RvAgain, echo = FALSE}
print(Rvmap)
```

Heap maps:

```{r plot_fig_10hmap, echo=F, fig.height=16, fig.width= 40}
gridExtra::grid.arrange(as.grob(hmap1$plot),as.grob(hmap2$plot),as.grob(hmap3$plot),
                        as.grob(hmap4$plot),as.grob(hmap5$plot),as.grob(hmap6$plot),
                        as.grob(hmap7$plot),as.grob(hmap8$plot),as.grob(hmap9$plot),
                        as.grob(hmap10$plot),ncol=5)
```

##### Component 1 & 2
```{r plot_fig12_mean, echo=F, fig.height=24, fig.width= 16}
gridExtra::grid.arrange(as.grob(hmap1$plot), as.grob(f01b.Fi.Ti),
                        as.grob(hmap1$plot), as.grob(f01c.Fi.CiTiMean), 
                        as.grob(hmap1$plot), as.grob(f01d.Fi.CiMean), ncol=2)
```

##### Component 2 & 3
```{r plot_fig23_mean, echo=F, fig.height=16, fig.width= 16}
gridExtra::grid.arrange(as.grob(hmap1$plot), as.grob(f02b.Fi.Mean),
                        as.grob(hmap1$plot), as.grob(f02c.Fi.CiMean), ncol=2)
```