---
title: "Demo_DiSTATIS"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,collapse=TRUE, comment="##")
```

## Idea
To test how different normalization works on a cube, we first run a DiSTATIS on this cube to get the result that we can compare the results from other techniques to.

## Objectives
Here, we illustrate the DiSTATIS results.

```{r cars, echo = FALSE, include = FALSE}
suppressMessages(library(psych))
suppressMessages(library(DistatisR))
suppressMessages(library(tidyr))
suppressMessages(library(magrittr))
suppressMessages(library(DistatisR))
suppressMessages(library(PTCA4CATA))
suppressMessages(library(ExPosition))
suppressMessages(library(InPosition))
suppressMessages(library(pheatmap))
suppressMessages(library(gridExtra))
suppressMessages(library(ggplotify))
suppressMessages(library(grid))
```


## Read data

```{r data, echo = FALSE, include = FALSE}
zmat.path <- "../data/zmat"
load(paste0(zmat.path,"/sub-MSC01_zcube_rcube.RData"))

parcel.comm.path <- "../data/parcel_community"
vox.des <- read.table(paste0(parcel.comm.path,"/sub-MSC01_node_parcel_comm.txt"),sep = ",")
colnames(vox.des) <- c("NodeID","VertexID","Comm")
vox.des$Comm.recode  <- dplyr::recode(vox.des$Comm, "0" = "A", "1" = "B", "2" = "C", "3" = "D", "4" = "E", "5" = "F", "6" = "G", "7" = "H", "8" = "I", "9" = "J", "10" = "K", "11" = "L", "12" = "M", "13" = "N", "14" = "O", "15" = "P", "16" = "Q", "17" = "R", "29" = "S")

```

This is a data cube of correlation: ROIs x ROIs x 10 sessions

```{r check, echo = TRUE, include = TRUE}
## Exclude negative correlations
cubes$rcube[cubes$rcube < 0] <- 0
# Dimensions
dim(cubes$rcube)
```

This correlation data are then transformed into distances (for DiSTATIS)

```{r dist}
dcube <- cor2dist(cubes$rcube)
# Dimension
dim(dcube)
```

Get community information and create colors for different communities
```{r comm}
## order nodes according to community
vox.order <- vox.des[order(vox.des$Comm.recode),]
rcube.order <- cubes$rcube[vox.order$NodeID,vox.order$NodeID,]
rownames(rcube.order) <- vox.order$NodeID
colnames(rcube.order) <- vox.order$NodeID
## Create colors from the community assignment vector
Comm.col <- vox.des$Comm.recode %>% as.data.frame %>% makeNominalData %>% createColorVectorsByDesign(hsv = FALSE, offset = 25)
## rename the rows and take away the first two periods
rownames(Comm.col$gc) %<>% sub("..", "", .)
## design matrix
vox.order.df <- data.frame(Comm = factor(vox.order$Comm.recode), row.names = rownames(rcube.order[,,1]))
vox.order.col <- list(Comm = c("A" = Comm.col$gc[1],
                               "B" = Comm.col$gc[2],
                               "C" = Comm.col$gc[3],
                               "D" = Comm.col$gc[4],
                               "E" = Comm.col$gc[5],
                               "F" = Comm.col$gc[6],
                               "G" = Comm.col$gc[7],
                               "H" = Comm.col$gc[8],
                               "I" = Comm.col$gc[9],
                               "J" = Comm.col$gc[10],
                               "K" = Comm.col$gc[11],
                               "L" = Comm.col$gc[12],
                               "M" = Comm.col$gc[13],
                               "N" = Comm.col$gc[14],
                               "O" = Comm.col$gc[15],
                               "P" = Comm.col$gc[16],
                               "Q" = Comm.col$gc[17],
                               "R" = Comm.col$gc[18],
                               "S" = Comm.col$gc[19]))
value.col <- colorRamps::blue2red(100)
```

## Check data with heatmap
```{r show_heatmap, echo = FALSE}
pheatmap(rcube.order[,,1],color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 0.5, cellheight = 0.5,
         annotation_col = vox.order.df,
         annotation_row = vox.order.df,
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = vox.order.col,
         breaks = seq(-1,1,by = 0.02),
         main="original correlation matrix")
```

```{r heatmap, echo = FALSE, fig.show = 'hide'}
hmap <- pheatmap(rcube.order[,,1],color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 0.8, cellheight = 0.8,
         annotation_col = vox.order.df,
         annotation_row = vox.order.df,
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = vox.order.col,
         breaks = seq(-1,1,by = 0.02),
         main="original correlation matrix")
```

## Run DiSTATIS
```{r distatis}
# DiSTATIS
distatis.res <- distatis(dcube)
```

## Plot results

### Rv space

#### Eigenvalues

```{r Rv.scree, echo = FALSE}
PlotScree(ev = distatis.res$res4Cmat$eigValues,
          title = "RV-map: Expained variance per dimension")
```

#### Factor scores

```{r Rv.f}
### Rv factor scores
rv.graph <- createFactorMap(distatis.res$res4Cmat$G,
                axis1 = 1, axis2 = 2)
### Dimension labels for the Rv map
rv.labels <- createxyLabels.gen(lambda = distatis.res$res4Cmat$eigValues,
                                tau = distatis.res$res4Cmat$tau,
                                axisName = "Dimension ")
### Show plot
Rvmap <- rv.graph$zeMap + rv.labels
print(Rvmap)
```

### Compromise space

#### Eigenvalues

```{r scree, echo = FALSE}
PlotScree(ev = distatis.res$res4Splus$eigValues,
          title = "Compromise: Explained variance per dimension")
```

Set the components of interest
```{r set.coi}
x_cp <- 1
y_cp <- 2
```

#### Factor scores

```{r f, echo = FALSE}
f.graph <- createFactorMap(distatis.res$res4Splus$F,
                           axis1 = x_cp, axis2 = y_cp,
                           title = "Compromise - Factor scores (nodes): cp 1 & 2",
                           col.points = Comm.col$oc,
                           alpha.points = .4, cex = 3)
f.graph.23 <- createFactorMap(distatis.res$res4Splus$F,
                           axis1 = 2, axis2 = 3,
                           title = "Compromise - Factor scores (nodes): cp 2 & 3",
                           col.points = Comm.col$oc,
                           alpha.points = .4, cex = 3)
f.labels <- createxyLabels.gen(x_axis = x_cp, y_axis = y_cp,
                               lambda = distatis.res$res4Splus$eigValues,
                               tau = distatis.res$res4Splus$tau,
                               axisName = "Dimension ")
f.labels.23 <- createxyLabels.gen(x_axis = 2, y_axis = 3,
                               lambda = distatis.res$res4Splus$eigValues,
                               tau = distatis.res$res4Splus$tau,
                               axisName = "Dimension ")
# Show plot
f01.Fi.noLabel <- f.graph$zeMap_background + f.graph$zeMap_dots + f.labels
f02.Fi.noLabel <- f.graph.23$zeMap_background + f.graph.23$zeMap_dots + f.labels.23
```

```{r plot_fig_f, echo=F, fig.height=8, fig.width= 16}
gridExtra::grid.arrange(as.grob(f01.Fi.noLabel), as.grob(f02.Fi.noLabel), ncol=2)
```

### Now plot the compromise space with means, confidence intervals, and tolerance intervals

#### Compute means for each network
```{r com.mean}
BootCube.Comm <- Boot4Mean(distatis.res$res4Splus$F,
                         design = vox.des$Comm.recode,
                         niter = 100,
                         suppressProgressBar = TRUE)
```

#### Plot

```{r makefig, echo = FALSE}
### Plot means
f.mean.graph <- createFactorMap(BootCube.Comm$GroupMeans,
                                axis1 = x_cp, axis2 = y_cp,
                                title = "Compromise - Factor scores with means of networks: cp 1 & 2",
                                col.points = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                constraints = f.graph$constraints,
                                col.labels = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                alpha.points = .8,
                                cex = 6)
### Plot means with its own constraints
f.mean.graph.owncon <- createFactorMap(BootCube.Comm$GroupMeans,
                                axis1 = x_cp, axis2 = y_cp,
                                title = "Compromise - Factor scores with means of networks: cp 2 & 3",
                                col.points = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                col.labels = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                alpha.points = .8,
                                cex = 6)
### Plot bootstrapped confidence intervals for means
f.CI.graph <- MakeCIEllipses(BootCube.Comm$BootCube[,c(x_cp,y_cp),],
                                    names.of.factors = c(sprintf("Factor %s",x_cp),sprintf("Factor %s",y_cp)),
                                    col = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                    p.level = .95)
### Plot tolerance intervals of each community
f.TI.graph <- MakeToleranceIntervals(distatis.res$res4Splus$F,
                                     axis1 = 1, axis2 = 2,
                                     design = vox.des$Comm,
                                     names.of.factors = c("Dim1", "Dim2"),
                                     col = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                     line.size = .50,
                                     line.type = 3,
                                     alpha.ellipse = .2,
                                     alpha.line = .4,
                                     p.level =.95)
# With CI and TI
f01b.Fi.CiTiMean <- f.graph$zeMap_background + f.TI.graph + f.graph$zeMap_dots + f.CI.graph + f.mean.graph$zeMap_dots + f.mean.graph$zeMap_text + f.labels

# With CI only
f01c.Fi.CiMean <- f.mean.graph.owncon$zeMap_background + f.mean.graph.owncon$zeMap_dots + f.CI.graph + f.labels + f.mean.graph.owncon$zeMap_text
```

```{r makefig.cp23, echo = FALSE, include = FALSE}
### Plot means
f.mean.graph.23 <- createFactorMap(BootCube.Comm$GroupMeans,
                                axis1 = 2, axis2 = 3,
                                title = "Compromise - Factor scores with means of networks",
                                col.points = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                constraints = f.graph$constraints,
                                col.labels = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                alpha.points = .8,
                                cex = T)
### Plot means with its own constraints
f.mean.graph.owncon.23 <- createFactorMap(BootCube.Comm$GroupMeans,
                                axis1 = 2, axis2 = 3,
                                title = "Compromise - Factor scores with means of networks",
                                col.points = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                col.labels = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                alpha.points = .8,
                                cex = 6)
### Plot bootstrapped confidence intervals for means
f.CI.graph.23 <- MakeCIEllipses(BootCube.Comm$BootCube[,c(2,3),],
                                    names.of.factors = c(sprintf("Factor %s",2),sprintf("Factor %s",3)),
                                    col = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                    p.level = .95)
# With mean
f02b.Fi.Mean <- f.graph.23$zeMap_background + f.graph.23$zeMap_dots + f.CI.graph.23 + f.mean.graph.23$zeMap_dots + f.mean.graph.23$zeMap_text + f.labels.23 
# With CI
f02c.Fi.CiMean <- f.mean.graph.owncon.23$zeMap_background + f.mean.graph.owncon.23$zeMap_dots + f.CI.graph.23 + f.labels.23 + f.mean.graph.owncon.23$zeMap_text
```

##### Component 1 & 2
```{r plot_fig12_mean, echo=F, fig.height=16, fig.width= 16}
gridExtra::grid.arrange(as.grob(hmap$gtable), as.grob(f01b.Fi.CiTiMean), 
                        as.grob(hmap$gtable), as.grob(f01c.Fi.CiMean), ncol=2)
```

##### Component 2 & 3
```{r plot_fig23_mean, echo=F, fig.height=16, fig.width= 16}
gridExtra::grid.arrange(as.grob(hmap$gtable), as.grob(f02b.Fi.Mean),
                        as.grob(hmap$gtable), as.grob(f02c.Fi.CiMean), ncol=2)
```