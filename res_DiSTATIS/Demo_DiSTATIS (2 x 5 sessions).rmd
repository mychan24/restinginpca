---
title: "Demo_DiSTATIS (2 x 5 sessions)"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,collapse=TRUE, comment="##")
```

## Idea
To test how different normalization works on a cube, we first run a DiSTATIS on this cube to get the result that we can compare the results from other techniques to.

## Objectives
Here, we illustrate the DiSTATIS results from the 1-5 sessions and 6-10 sessions of subject 1 separately.

```{r cars, echo = FALSE, include = FALSE}
suppressMessages(library(psych))
suppressMessages(library(DistatisR))
suppressMessages(library(tidyr))
suppressMessages(library(magrittr))
suppressMessages(library(DistatisR))
suppressMessages(library(PTCA4CATA))
suppressMessages(library(ExPosition))
suppressMessages(library(InPosition))
suppressMessages(library(superheat))
suppressMessages(library(gridExtra))
suppressMessages(library(ggplotify))
suppressMessages(library(grid))
# Read functions
tool.path <- "../tools/"
source(paste0(tool.path,"SScomm.R"))
```


## Read data

```{r data, echo = FALSE, include = FALSE}
zmat.path <- "../data/zmat"
load(paste0(zmat.path,"/sub-MSC01_zcube_rcube.RData"))
# read parcel labels
parcel.comm.path <- "../data/parcel_community"
vox.des <- read.table(paste0(parcel.comm.path,"/sub-MSC01_node_parcel_comm.txt"),sep = ",")
colnames(vox.des) <- c("NodeID","VertexID","Comm")
# rename communities
CommName <- read.csv(paste0(parcel.comm.path,"/systemlabel.txt"),sep = ",",header = FALSE)
colnames(CommName) <- c("Comm","CommLabel","CommColor","CommLabel.short")
for(i in 1:nrow(CommName)){
  vox.des$Comm.recode[vox.des$Comm==CommName$Comm[i]] <- as.character(CommName$CommLabel[i])
  vox.des$Comm.Col[vox.des$Comm==CommName$Comm[i]] <- as.character(CommName$CommColor[i])
  vox.des$Comm.rcd[vox.des$Comm==CommName$Comm[i]] <- as.character(CommName$CommLabel.short[i])
}
# Create design matrix for communities
vox.des.mat <- makeNominalData(as.matrix(vox.des$Comm.rcd))
colnames(vox.des.mat) <- sub(".","",colnames(vox.des.mat))
```

This is a data cube of correlation: ROIs x ROIs x 10 sessions

```{r check, echo = TRUE, include = TRUE}
## Exclude negative correlations
cubes$rcube[cubes$rcube < 0] <- 0
# Dimensions
dim(cubes$rcube)
```

This correlation data are then transformed into distances (for DiSTATIS). The distance data are separated into the first 5 sessions and the last 5 sessions.

```{r dist}
dcube <- cor2dist(cubes$rcube)
dcube_first5 <- cor2dist(cubes$rcube[,,1:5])
dcube_last5 <- cor2dist(cubes$rcube[,,6:10])
# Dimension
dim(dcube_first5)
dim(dcube_last5)
```

## Compute SS of each community

```{r SS, include = FALSE}
# SS of correlation
ss_rcube <- SScomm(cubes$rcube,vox.des.mat)
# SS of distance
ss_dcube <- SScomm(dcube,vox.des.mat)

```

Get community information and create colors for different communities
```{r comm}
Comm.col <- list(oc = as.matrix(vox.des$Comm.Col), gc = as.matrix(CommName$CommColor))
rownames(Comm.col$oc) <- vox.des$NodeID
rownames(Comm.col$gc) <- CommName$CommLabel.short
```

## Check data with heatmap for the 1st session
```{r show_heatmap, echo = FALSE, fig.height= 16, fig.width = 16}
superheat(cubes$rcube[,,1],
          membership.cols = vox.des$Comm.rcd,
          membership.rows = vox.des$Comm.rcd,
          clustering.method = NULL,
          heat.lim = c(0, 1), 
          heat.pal = parula(20),
          heat.pal.values = c(0, 0.5, 1),
          left.label.size = 0.08,
          bottom.label.size = 0.05,
          y.axis.reverse = TRUE,
          left.label.col = Comm.col$gc[order(rownames(Comm.col$gc))], # order by community name
          bottom.label.col = Comm.col$gc[order(rownames(Comm.col$gc))],
          left.label.text.size = c(rep(6,4), rep(3,3),6,3,  rep(6,2),3,rep(6,5),3,3),
          bottom.label.text.size = 2,
          left.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
          bottom.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
          left.label.text.alignment = "left",
          title = "Correlation matric of the 1st session"
)
```

## Check the sums of squares (of correlation matrix) of the 1st session

```{r SS_heatR_1, echo = FALSE, fig.height= 16, fig.width = 16}
superheat(ss_rcube[,,1],
          membership.cols = rownames(ss_rcube[,,1]),
          membership.rows = colnames(ss_rcube[,,1]),
          clustering.method = NULL,
          heat.lim = c(0, 1300), 
          heat.pal = parula(20),
          heat.pal.values = c(0, 0.5, 1),
          left.label.size = 0.08,
          bottom.label.size = 0.05,
          y.axis.reverse = TRUE,
          left.label.col = Comm.col$gc[order(rownames(Comm.col$gc))], # order by community name
          bottom.label.col = Comm.col$gc[order(rownames(Comm.col$gc))],
          left.label.text.size = 6,
          bottom.label.text.size = 4,
          left.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
          bottom.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
          left.label.text.alignment = "left"
)
```

## Check the sums of squares (of distance matrix) of the 1st session

```{r SS_heatD_1, echo = FALSE, fig.height= 16, fig.width = 16}
superheat(ss_dcube[,,1],
          membership.cols = rownames(ss_rcube[,,1]),
          membership.rows = colnames(ss_rcube[,,1]),
          clustering.method = NULL,
          heat.lim = c(0, 15200), 
          heat.pal = parula(20),
          heat.pal.values = c(0, 0.5, 1),
          left.label.size = 0.08,
          bottom.label.size = 0.05,
          y.axis.reverse = TRUE,
          left.label.col = Comm.col$gc[order(rownames(Comm.col$gc))], # order by community name
          bottom.label.col = Comm.col$gc[order(rownames(Comm.col$gc))],
          left.label.text.size = 6,
          bottom.label.text.size = 4,
          left.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
          bottom.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
          left.label.text.alignment = "left"
)
```


## Run DiSTATIS
```{r distatis}
# DiSTATIS
distatis.res_first5 <- distatis(dcube_first5)
distatis.res_last5 <- distatis(dcube_last5)
```

## Plot results

### Rv space

#### Eigenvalues

```{r Rv.scree, echo = FALSE}
PlotScree(ev = distatis.res_first5$res4Cmat$tau,
          title = "RV-map (first 5): Expained variance per dimension")
PlotScree(ev = distatis.res_first5$res4Cmat$tau,
          title = "RV-map (last 5): Expained variance per dimension")
```

#### Factor scores

```{r Rv.f, fig.show='hide'}
### Rv factor scores
rv.graph_first5 <- createFactorMap(distatis.res_first5$res4Cmat$G,
                axis1 = 1, axis2 = 2)
rv.graph_last5 <- createFactorMap(distatis.res_last5$res4Cmat$G,
                axis1 = 1, axis2 = 2)

### Dimension labels for the Rv map
rv.labels_first5 <- createxyLabels.gen(lambda = distatis.res_first5$res4Cmat$eigValues,
                                tau = distatis.res_first5$res4Cmat$tau,
                                axisName = "Dimension ")
rv.labels_last5 <- createxyLabels.gen(lambda = distatis.res_last5$res4Cmat$eigValues,
                                tau = distatis.res_last5$res4Cmat$tau,
                                axisName = "Dimension ")

### Show plot
Rvmap_first5 <- rv.graph_first5$zeMap + rv.labels_first5
Rvmap_last5 <- rv.graph_last5$zeMap + rv.labels_last5

```


```{r show.Rv.f, echo=F, fig.height=8, fig.width= 16}
gridExtra::grid.arrange(as.grob(Rvmap_first5), as.grob(Rvmap_last5),
                        ncol=2)
```

### Compromise space

#### Eigenvalues

```{r scree, echo = FALSE}
PlotScree(ev = distatis.res_first5$res4Splus$tau,
          title = "Compromise (first 5): Explained variance per dimension")
PlotScree(ev = distatis.res_last5$res4Splus$tau,
          title = "Compromise (last 5): Explained variance per dimension")
```

#### Factor scores

```{r f, echo = FALSE}
# plot factor scores
f.graph_first5 <- createFactorMap(distatis.res_first5$res4Splus$F,
                           axis1 = 1, axis2 = 2,
                           title = "Compromise (first 5) - Factor scores (nodes): cp 1 & 2",
                           col.points = Comm.col$oc,
                           alpha.points = .4, cex = 3)
f.graph_last5 <- createFactorMap(distatis.res_last5$res4Splus$F,
                           axis1 = 1, axis2 = 2,
                           title = "Compromise (last 5) - Factor scores (nodes): cp 1 & 2",
                           col.points = Comm.col$oc,
                           alpha.points = .4, cex = 3)
# labels
f.labels_first5 <- createxyLabels.gen(x_axis = 1, y_axis = 2,
                               lambda = distatis.res_first5$res4Splus$eigValues,
                               tau = distatis.res_first5$res4Splus$tau,
                               axisName = "Dimension ")
f.labels_last5 <- createxyLabels.gen(x_axis = 1, y_axis = 2,
                               lambda = distatis.res_last5$res4Splus$eigValues,
                               tau = distatis.res_last5$res4Splus$tau,
                               axisName = "Dimension ")
# Show plot
f01a.Fi.noLabel <- f.graph_first5$zeMap_background + f.graph_first5$zeMap_dots + f.labels_first5
f02a.Fi.noLabel <- f.graph_last5$zeMap_background + f.graph_last5$zeMap_dots + f.labels_last5
```

```{r plot_fig_f, echo=F, fig.height=8, fig.width= 16}
gridExtra::grid.arrange(as.grob(f01a.Fi.noLabel), as.grob(f02a.Fi.noLabel), ncol=2)
```

### Now plot the compromise space with means, confidence intervals, and tolerance intervals

#### Compute means for each network
```{r com.mean}
BootCube.Comm <- Boot4Mean(distatis.res$res4Splus$F,
                         design = vox.des$Comm.rcd,
                         niter = 100,
                         suppressProgressBar = TRUE)
```

#### Plot

```{r makefig, echo = FALSE}
### Plot means
f.mean.graph <- createFactorMap(BootCube.Comm$GroupMeans,
                                axis1 = x_cp, axis2 = y_cp,
                                title = "Compromise - Factor scores with means of networks: cp 1 & 2",
                                col.points = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                constraints = f.graph$constraints,
                                col.labels = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                alpha.points = .8,
                                pch = 15,
                                cex = 5)
### Plot means with its own constraints
f.mean.graph.owncon <- createFactorMap(BootCube.Comm$GroupMeans,
                                axis1 = x_cp, axis2 = y_cp,
                                title = "Compromise - Factor scores with means of networks: cp 1 & 2",
                                col.points = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                col.labels = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                alpha.points = .8,
                                pch = 15,
                                cex = 5)
### Plot bootstrapped confidence intervals for means
f.CI.graph <- MakeCIEllipses(BootCube.Comm$BootCube[,c(x_cp,y_cp),],
                                    names.of.factors = c(sprintf("Factor %s",x_cp),sprintf("Factor %s",y_cp)),
                                    col = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                    p.level = .95)
### Plot tolerance intervals of each community
f.TI.graph <- MakeToleranceIntervals(distatis.res$res4Splus$F,
                                     axis1 = x_cp, axis2 = y_cp,
                                     design = vox.des$Comm,
                                     names.of.factors = c("Dim1", "Dim2"),
                                     col = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                     line.size = .50,
                                     line.type = 3,
                                     alpha.ellipse = .2,
                                     alpha.line = .4,
                                     p.level =.95)
# With TI only
f01b.Fi.Ti <- f.graph$zeMap_background + f.TI.graph + f.graph$zeMap_dots + f.labels
# With CI and TI
f01c.Fi.CiTiMean <- f.graph$zeMap_background + f.TI.graph + f.graph$zeMap_dots + f.CI.graph + f.mean.graph$zeMap_dots + f.mean.graph$zeMap_text + f.labels
# CI only
f01d.Fi.CiMean <- f.mean.graph.owncon$zeMap_background + f.mean.graph.owncon$zeMap_dots + f.CI.graph + f.labels + f.mean.graph.owncon$zeMap_text
```

```{r makefig.cp23, echo = FALSE, include = FALSE}
### Plot means
f.mean.graph.23 <- createFactorMap(BootCube.Comm$GroupMeans,
                                axis1 = 2, axis2 = 3,
                                title = "Compromise - Factor scores with means of networks: cp 2 & 3",
                                col.points = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                constraints = f.graph$constraints,
                                col.labels = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                alpha.points = .8,
                                pch = 15,
                                cex = 5)
### Plot means with its own constraints
f.mean.graph.owncon.23 <- createFactorMap(BootCube.Comm$GroupMeans,
                                axis1 = 2, axis2 = 3,
                                title = "Compromise - Factor scores with means of networks: cp 2 & 3",
                                col.points = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                col.labels = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                alpha.points = .8,
                                pch = 15,
                                cex = 5)
### Plot bootstrapped confidence intervals for means
f.CI.graph.23 <- MakeCIEllipses(BootCube.Comm$BootCube[,c(2,3),],
                                    names.of.factors = c(sprintf("Factor %s",2),sprintf("Factor %s",3)),
                                    col = Comm.col$gc[rownames(BootCube.Comm$GroupMeans),],
                                    p.level = .95)
# With mean
f02b.Fi.Mean <- f.graph.23$zeMap_background + f.graph.23$zeMap_dots + f.CI.graph.23 + f.mean.graph.23$zeMap_dots + f.mean.graph.23$zeMap_text + f.labels.23

# With CI
f02c.Fi.CiMean <- f.mean.graph.owncon.23$zeMap_background + f.mean.graph.owncon.23$zeMap_dots + f.CI.graph.23 + f.labels.23 + f.mean.graph.owncon.23$zeMap_text
```

##### All heat maps and Rv
```{r all_hmap, echo = FALSE, fig.show = 'hide'}
for(session.count in 1:dim(cubes$rcube)[3]){
  # heat map of correlation matrices
  hmap.name <- sprintf("hmap%s",session.count)
  assign(hmap.name, superheat(cubes$rcube[,,session.count],
                              membership.cols = vox.des$Comm.rcd,
                              membership.rows = vox.des$Comm.rcd,
                              clustering.method = NULL,
                              heat.col.scheme = "viridis",
                              left.label.size = 0.08,
                              bottom.label.size = 0.05,
                              y.axis.reverse = TRUE,
                              left.label.col = Comm.col$gc[order(rownames(Comm.col$gc))], # order by community name
                              bottom.label.col = Comm.col$gc[order(rownames(Comm.col$gc))],
                              left.label.text.size = 3,
                              bottom.label.text.size = 2,
                              left.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
                              bottom.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
                              left.label.text.alignment = "left",
                              title = sprintf("Correlation matrix of #%s session",session.count)
  ))
  # heat map of SS of correlation matrices
  rSS_hmap.name <- sprintf("rSS_hmap%s", session.count)
  assign(rSS_hmap.name,superheat(ss_rcube[,,1],
                                membership.cols = rownames(ss_rcube[,,session.count]),
                                membership.rows = colnames(ss_rcube[,,session.count]),
                                clustering.method = NULL,
                                heat.col.scheme = "viridis",
                                left.label.size = 0.08,
                                bottom.label.size = 0.05,
                                y.axis.reverse = TRUE,
                                left.label.col = Comm.col$gc[order(rownames(Comm.col$gc))], # order by community name
                                bottom.label.col = Comm.col$gc[order(rownames(Comm.col$gc))],
                                left.label.text.size = 3,
                                bottom.label.text.size = 2,
                                left.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
                                bottom.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
                                left.label.text.alignment = "left"
  ))
  # heat map of SS of correlation matrices
  dSS_hmap.name <- sprintf("dSS_hmap%s", session.count)
  assign(dSS_hmap.name,superheat(ss_dcube[,,session.count],
                                membership.cols = rownames(ss_dcube[,,session.count]),
                                membership.rows = colnames(ss_dcube[,,session.count]),
                                clustering.method = NULL,
                                heat.col.scheme = "viridis",
                                left.label.size = 0.08,
                                bottom.label.size = 0.05,
                                y.axis.reverse = TRUE,
                                left.label.col = Comm.col$gc[order(rownames(Comm.col$gc))], # order by community name
                                bottom.label.col = Comm.col$gc[order(rownames(Comm.col$gc))],
                                left.label.text.size = 3,
                                bottom.label.text.size = 2,
                                left.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
                                bottom.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
                                left.label.text.alignment = "left"
  ))
}
```
Rv factor scores:

```{r RvAgain, echo = FALSE}
print(Rvmap)
```

Heap maps of correlation matrices:

```{r plot_fig_10hmap, echo=F, fig.height=16, fig.width= 40}
gridExtra::grid.arrange(as.grob(hmap1$plot),as.grob(hmap2$plot),as.grob(hmap3$plot),
                        as.grob(hmap4$plot),as.grob(hmap5$plot),as.grob(hmap6$plot),
                        as.grob(hmap7$plot),as.grob(hmap8$plot),as.grob(hmap9$plot),
                        as.grob(hmap10$plot),ncol=5)
```

Heap maps of SS of correlation matrices:

```{r plot_fig_10rSShmap, echo=F, fig.height=16, fig.width= 40}
gridExtra::grid.arrange(as.grob(rSS_hmap1$plot),as.grob(rSS_hmap2$plot),as.grob(rSS_hmap3$plot),
                        as.grob(rSS_hmap4$plot),as.grob(rSS_hmap5$plot),as.grob(rSS_hmap6$plot),
                        as.grob(rSS_hmap7$plot),as.grob(rSS_hmap8$plot),as.grob(rSS_hmap9$plot),
                        as.grob(rSS_hmap10$plot),ncol=5)
```

Heap maps of SS of distance matrices:

```{r plot_fig_10dSShmap, echo=F, fig.height=16, fig.width= 40}
gridExtra::grid.arrange(as.grob(dSS_hmap1$plot),as.grob(dSS_hmap2$plot),as.grob(dSS_hmap3$plot),
                        as.grob(dSS_hmap4$plot),as.grob(dSS_hmap5$plot),as.grob(dSS_hmap6$plot),
                        as.grob(dSS_hmap7$plot),as.grob(dSS_hmap8$plot),as.grob(dSS_hmap9$plot),
                        as.grob(dSS_hmap10$plot),ncol=5)
```

##### Component 1 & 2

```{r plot_fig12_mean, echo=F, fig.height=24, fig.width= 16}
gridExtra::grid.arrange(as.grob(hmap1$plot), as.grob(f01b.Fi.Ti),
                        as.grob(hmap1$plot), as.grob(f01c.Fi.CiTiMean), 
                        as.grob(hmap1$plot), as.grob(f01d.Fi.CiMean), ncol=2)
```

##### Component 2 & 3
```{r plot_fig23_mean, echo=F, fig.height=16, fig.width= 16}
gridExtra::grid.arrange(as.grob(hmap1$plot), as.grob(f02b.Fi.Mean),
                        as.grob(hmap1$plot), as.grob(f02c.Fi.CiMean), ncol=2)
```

## Interpretation

#### From JCY:

* Distance in the factor score maps illustrate the relationship between two networks with a shorter distance reflecting a stronger correlation

* Component 1: Defult mode (DMN) VS Cingulo-opercular (CON)
    
    + DMN and CON have almost opposite pattern in several big networks (i.e., lateral Visual (lVis), DMN, CON, ventral attention (vATN), Salience(SLC))
    
    + Stronger correlation to DMN: vATN,
    
    + Stronger correlation to CON: lVis, mVis, CON, SLC

* Component 2: DMN -> CON -> Fronto-parietal (FPN) & dorsal attention (dATN)

    + FPN is the network with the most SS of correlation, CON is the second most, and DMN is the third most
    
    + FPN is not does not share pattern with either DMN or CON and only connects to these two networks moderately
    
    + FPN is stronly correlated only to dATN

* Component 3: Sensorimotor networds VS Salience, medial temporal (MTL)

    + All sensorimotor networks have small correlation to salience, parietal memory (PMN) and mVis networks
    
    + Salience, PMN, and mVis all have small correlation to sensorimotor, attention, PMN, Auditory, and MTL networks
    
    + These are seen in both the correlation matrix and the SS of correlation
    
#### from MYC: 
* Factor 1: 
    + I agree with your observation. 
    + Default Mode (DMN) and Cingular-Opercular Network (CON) being opposite is not surprising. CON is the top-down processing attentional network that is quite different from frontal-parietal network (FPN), which shares more similarity with DMN. 
So along Factor 1, we see DMN, FP and its cousin DAN on one side, and CON on the other (along with Salience [SAN]).  
    + **One thing to note is that there are very few nodes in some of these networks. The normalization allows them to give a bigger contribution despite their smaller size, but they are also just less consistent (thus the a larger confidence interval for networks like Salience).** <- correct me if this is a wrong way to view how network-size interacts with normalization and therefore the interpretation. 

* Factor 2: 
    + Here we have Frontal Parietal (FPN) and its cousin Dorsal Attention Network (DAN) pulling weight on one side, and essentially the rest of the stuff along the middle, and maybe DMN, Ventral Attention Network (VAN), and Auditory (AUD) on the other.
    + The VAN is topographically (physically) located close to Auditory areas, and has decent connection to DMN. VAN and DAN are sort of opposite in their connection pattern, so that may be why they are on opposite sides. 
    + **I’m not sure how the SS of correlation plays into the explanation for Factor 2? Because DAN has a rather weak SS correlation, but its at the very end factor 2.**

* Factor 3: Differentiating between Visual networks from the rest of the sensory-motor networks
    + Here we have all the motor (premotor, hand/face motor) networks & auditory (AUD) opposing the visual networks plus Salience, which shows moderate correlation to both Visual networks. I think that is the bigger contrast for factor 3. 
