---
title: "Demonstrating STATIS normalization on a correlation matrix"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,collapse=TRUE, comment="##")
```

## Idea
Before starting this project, we were not sure how we should normalize our data to control for counding factors (e.g., voxel size and network size) and keep important signals. (But what is really the important information?) Since the correlation matrix we work on resemble a distance matrix. We came up with the idea of matrix preprocessing steps similar to that of DiSTATIS (i.e., STATIS for distance matrices). This type of preprocessing consists of two steps:

* Double-center
* Normalized by the first eigenvalue of the double-centered matrix

## Objectives
Here, we illustrate how data are changed along these steps and how the final singular value  decomposition (SVD) results are affected.

## Start with an example data

```{r cars, echo = FALSE, include = FALSE}
suppressMessages(library(dplyr))
suppressMessages(library(tidyr))
suppressMessages(library(PTCA4CATA))
suppressMessages(library(ExPosition))
suppressMessages(library(InPosition))
suppressMessages(library(pheatmap))
suppressMessages(library(gridExtra))
suppressMessages(library(ggplotify))
suppressMessages(library(grid))
```

### Fake data
We start with a fake data with blocks of correlation.

```{r pressure, echo = FALSE}
X <- as.matrix(read.csv("FakeData.csv"))
head(X)
```

### Fake correlation
Then, compute its correlation matrix.

```{r correlation}
### fake correlation:
# substitue all negative correlations to 0
cor.X <- cor(X)
cor.X[cor(X) < 0] <- 0
dim(cor.X)
```

Setting up colors for plotting
```{r color_setting}
group.col <- RColorBrewer::brewer.pal(5,"Set1")[c(rep(x=1,8),rep(x=2,9),rep(x=3,9),rep(x=4,8),rep(x=5,10))]
group.des <- c(rep("E",8),rep("A",9),rep("C",9),rep("N",8),rep("O",10))
group.des.nominal <- makeNominalData(as.matrix(group.des))
group.des.nomnorm <- group.des.nominal/c(rep(8,8),rep(9,9),rep(9,9),rep(8,8),rep(10,10))
group.des.df <- data.frame(group = factor(group.des),row.names = colnames(X))
group.des.col <- list(group = c(E = RColorBrewer::brewer.pal(5,"Set1")[1],
                                A = RColorBrewer::brewer.pal(5,"Set1")[2],
                                C = RColorBrewer::brewer.pal(5,"Set1")[3],
                                N = RColorBrewer::brewer.pal(5,"Set1")[4],
                                O = RColorBrewer::brewer.pal(5,"Set1")[5]))
value.col <- colorRamps::blue2red(100)
```


### The heatmap:
Given that all networks have strong within connection, we want to differentiate networks that:

* have low between-network connection (an isolate network) -- E and N
* have strong connection with one other network -- A and C
* have strong connection with two (or more) other network -- O

```{r show_cor, echo = FALSE}
p_o <- pheatmap(cor.X, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 7,cellheight = 7,
         annotation_col = group.des.df,
         annotation_row = group.des.df,
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-1,1,by = 0.02),
         main="original matrix")
```

## STATIS-like normalization

### STEP 1 : Double centering
Centering across columns and rows so that each row and column has a mean of 0.

```{r double_center}
# center columns and rows
corX.c <- cor.X %>% scale(scale = FALSE) %>% t %>% scale(scale = FALSE)
```

```{r show_center, echo = FALSE, fig.show='hide'}
p_dc <- pheatmap(corX.c, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 7,cellheight = 7,
         annotation_col = group.des.df,
         annotation_row = group.des.df,
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-1,1,by = 0.02),
         main="double-centered matrix")
```

### STEP 1.5: Eigen decomposition
Perform an eigen decomposition and record the eigenvalues.

```{r eig}
# get the first eigenvalue
eig.res.corX <-eigen(corX.c)
Lambda.corX <- eig.res.corX$`values`
Q.corX <- eig.res.corX$vectors
Q1 <- as.matrix(diag(Q.corX[,1]))
rownames(Q1) <- colnames(X)
colnames(Q1) <- colnames(X)
```

Plot eigen vectors:

```{r show_eig, echo = FALSE, fig.show='hide'}
p_e <- pheatmap(Q1, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 7,cellheight = 7,
         annotation_col = group.des.df,
         annotation_row = group.des.df,
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         main="eigan vectors"
         )
```

```{r plot_dc_ev, echo=F, fig.height=8, fig.width=14}
gridExtra::grid.arrange(as.grob(p_dc$gtable), as.grob(p_e$gtable), ncol=2)
```

Double-centering subtracts the most from the network that connects most to other networks.

### STEP 2 : Devided the double-centered matrix by the first eigenvalue
```{r d_eig}
end.X <- corX.c/Lambda.corX[1]
```

```{r show_endX, echo = FALSE, fig.show='hide'}
p_n <- pheatmap(end.X, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 7,cellheight = 7,
         annotation_col = group.des.df,
         annotation_row = group.des.df,
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-0.25,0.25,by = 0.005),
         main="STATIS-like normalized matrix")
```

#### Compared the STATIS-like normalized matrix to the original matrix:

As mentioned above, when we double-center the matrix, the value subtracted from the most connected network will be large, and thus the value will become smaller than those who connect less to other networks.

```{r o_n_mat, echo=F, fig.width=14, fig.height=8}
gridExtra::grid.arrange(as.grob(p_n$gtable), as.grob(p_o$gtable), nrow=1)
```

Sums of squares of the normalized matrix:

```{r ss_endX, echo = FALSE, fig.show='hide'}
ss_endX <- t(group.des.nominal) %*% end.X^2 %*% group.des.nominal
rownames(ss_endX) <- c("E","A","C","N","O")
colnames(ss_endX) <- c("E","A","C","N","O")
ss_endX
p_ns2 <- pheatmap(ss_endX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-0.1,0.1,by = 0.002),
         main = "sums of squares")
p_ns2_d <- pheatmap(ss_endX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(0.3,0.6,by = 0.003),
         main = "diagonal of sums of squares")
```

Normalized sums of squares of the normalized matrix:

```{r NormSS_endX,echo = FALSE, fig.show='hide'}
NormSS_endX <- t(group.des.nomnorm) %*% end.X^2 %*% group.des.nomnorm
rownames(NormSS_endX) <- c("E","A","C","N","O")
colnames(NormSS_endX) <- c("E","A","C","N","O")
NormSS_endX
p_nns2 <- pheatmap(NormSS_endX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-0.002,0.002,by = 0.00004),
         main = "normalized sums of squares")
p_nns2_d <- pheatmap(NormSS_endX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(0.004,0.009,by = 0.00005),
         main = "diagonal of normalized sums of squares")
```

Block means:

```{r mean_endX, echo = FALSE, fig.show='hide'}
mean_endX <- t(group.des.nomnorm) %*% end.X %*% group.des.nomnorm
rownames(mean_endX) <- c("E","A","C","N","O")
colnames(mean_endX) <- c("E","A","C","N","O")
mean_endX
p_nm <- pheatmap(mean_endX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-0.03,0.03,by = 0.0006),
         main="mean")
p_nm_d <- pheatmap(mean_endX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(0.03,0.08,by = 0.0005),
         main = "diagonal of mean")

```

Sums of squares of the original matrix:

```{r ss_corX,echo = FALSE, fig.show='hide'}
ss_corX <- t(group.des.nominal) %*% cor.X^2 %*% group.des.nominal
rownames(ss_corX) <- c("E","A","C","N","O")
colnames(ss_corX) <- c("E","A","C","N","O")
ss_corX
p_os2 <- pheatmap(ss_corX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-6,6,by = 0.12),
         main="original mat SS")
p_os2_d <- pheatmap(ss_corX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(11,26,by = 0.15),
         main="diagonal of original mat SS")

```

Normalized sums of squares:

```{r NormSS_corX,echo = FALSE, fig.show='hide'}
NormSS_corX <- t(group.des.nomnorm) %*% cor.X^2 %*% group.des.nomnorm
rownames(NormSS_corX) <- c("E","A","C","N","O")
colnames(NormSS_corX) <- c("E","A","C","N","O")
NormSS_corX
p_ons2 <- pheatmap(NormSS_corX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-0.1,0.1,by = 0.002),
         main="original mat normalized-SS")
p_ons2_d <- pheatmap(NormSS_corX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(0.18,0.26,by = 0.0008),
         main="diagonal of original mat normalized-SS")
```

Plot them:

```{r mean_corX,echo = FALSE, fig.show='hide'}
mean_corX <- t(group.des.nomnorm) %*% cor.X %*% group.des.nomnorm
rownames(mean_corX) <- c("E","A","C","N","O")
colnames(mean_corX) <- c("E","A","C","N","O")
mean_corX
p_om <- pheatmap(mean_corX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(-0.2,0.2,by = 0.004),
         main="original mat mean")
p_om_d <- pheatmap(mean_corX, color = value.col,
         cluster_cols = FALSE, cluster_rows = FALSE,
         cellwidth = 35,cellheight = 35,
         annotation_col = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_row = data.frame(group = group.des.df[c(1,9,18,27,35),]),
         annotation_legend = FALSE,
         annotation_names_col = FALSE,
         annotation_names_row = FALSE,
         annotation_colors = group.des.col,
         breaks = seq(0.3,0.5,by = 0.002),
         main="diagonal of original mat mean")
```

```{r grid_small_mats, echo=F, fig.width=14, fig.height=16}
gridExtra::grid.arrange(as.grob(p_os2$gtable), as.grob(p_ons2$gtable), as.grob(p_om$gtable),
                        as.grob(p_ns2$gtable), as.grob(p_nns2$gtable), as.grob(p_nm$gtable), 
                        as.grob(p_os2_d$gtable), as.grob(p_ons2_d$gtable), as.grob(p_om_d$gtable),
                        as.grob(p_ns2_d$gtable), as.grob(p_nns2_d$gtable), as.grob(p_nm_d$gtable),
                        ncol=3)
```

## Try PCA
### PCA results with STATIS-normalized and original matrix

Let's see how the PCA results are changed after the STATIS-like normalization.

```{r pca_set}
# Group design
group.des <- c(rep(x=1,8),rep(x=2,9),rep(x=3,9),rep(x=4,8),rep(x=5,10))
# PCA with original correlation matrix
corX.pca.res <- epPCA(cor.X, center = FALSE, scale = FALSE, DESIGN = group.des, make_design_nominal = TRUE, graphs = FALSE)
# PCA with the STATIS-normalized matrix
endX.pca.res <- epPCA(end.X, center = FALSE, scale = FALSE, DESIGN = group.des, make_design_nominal = TRUE, graphs = FALSE)

```

```{r pcaRes_corX, echo = FALSE}
par(mfrow=c(1,2))
corX.p <- createFactorMap(corX.pca.res$ExPosition.Data$fi,
                          col.points = group.col,
                          col.labels = group.col,
                          display.points = TRUE,
                          display.labels = TRUE,
                          title = "PCA on original matrix _ component 1 & 2"
)
corX.p23 <- createFactorMap(corX.pca.res$ExPosition.Data$fi,
                            axis1 = 2,
                            axis2 = 3,
                            col.points = group.col,
                            col.labels = group.col,
                            display.points = TRUE,
                            display.labels = TRUE,
                            title = "PCA on original matirx _ component 2 & 3"
)
labels4corX <- createxyLabels.gen(
  lambda = corX.pca.res$ExPosition.Data$eigs ,
  tau = corX.pca.res$ExPosition.Data$t,
  axisName = "Dimension ")
labels4corX23 <- createxyLabels.gen(
  lambda = corX.pca.res$ExPosition.Data$eigs[c(2:3)],
  tau = corX.pca.res$ExPosition.Data$t[c(2:3)],
  axisName = "Dimension ")
pca.o.12 <- corX.p$zeMap + labels4corX
pca.o.23 <- corX.p23$zeMap + labels4corX23
```

```{r pcaRes_endX, echo = FALSE}
endX.p <- createFactorMap(endX.pca.res$ExPosition.Data$fi,
                          col.points = group.col,
                          col.labels = group.col,
                          display.points = TRUE,
                          display.labels = TRUE,
                          title = "PCA on the STATIS-like normalized matrix"
)
labels4endX <- createxyLabels.gen(
  lambda = endX.pca.res$ExPosition.Data$eigs ,
  tau = endX.pca.res$ExPosition.Data$t,
  axisName = "Dimension ")
pca.n <- endX.p$zeMap + labels4endX
```

#### Compare
```{r grid_scree, echo=F, fig.width=14, fig.height=5}
corX.pca.inf.res <- epPCA.inference.battery(cor.X, center = FALSE, scale = FALSE, DESIGN = group.des, make_design_nominal = TRUE, graphs = FALSE)
# PCA with the STATIS-normalized matrix
endX.pca.inf.res <- epPCA.inference.battery(end.X, center = FALSE, scale = FALSE, DESIGN = group.des, make_design_nominal = TRUE, graphs = FALSE)
# Set plotting parameters to 2 columns
par(mfrow=c(1,2))

# Scree plot of PCA on the STATIS-like normalized matrix
PlotScree(ev = endX.pca.res$ExPosition.Data$eigs, p.ev = corX.pca.inf.res$Inference.Data$components$p.vals,title = "PCA on the STATIS-like normalized matrix")

# Scree plot of PCA on the original matrix
PlotScree(ev = corX.pca.res$ExPosition.Data$eigs, p.ev = corX.pca.inf.res$Inference.Data$components$p.vals, title = "PCA on the original matrix")
# Reset the plotting parameter to default
par(mfrow=c(1,1))
```

* The network with the largest size will dominate the first component.
* The first component gives the frequency of connections for each network.
* The second component differentiates different isolated networks.

When compared to PCA of the original matrix, the STATIS-like normalization is similar to a rotation for components 1 and 2. The third component is not making much sense.

```{r grid_pca, echo=F, fig.width=18, fig.height=16}
gridExtra::grid.arrange(as.grob(p_o$gtable),as.grob(pca.n), as.grob(pca.o.12),
                        as.grob(p_o$gtable),as.grob(pca.n), as.grob(pca.o.23),
                        ncol=3)
```

#### Question?

* The first two components seem to capture what we care about. The question now is: Will these first two components survive if we reshape this normalized matrix and do PCA on the its rectangular form?   


### To be continued...


