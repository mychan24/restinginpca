
---
title: "MuSu_(NA, c, NA)"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressMessages(library(pander))
suppressMessages(library(psych))
suppressMessages(library(DistatisR))
suppressMessages(library(tidyr))
suppressMessages(library(magrittr))
suppressMessages(library(DistatisR))
suppressMessages(library(PTCA4CATA))
suppressMessages(library(ExPosition))
suppressMessages(library(InPosition))
suppressMessages(library(superheat))
suppressMessages(library(gridExtra))
suppressMessages(library(ggplotify))
suppressMessages(library(grid))
suppressMessages(library(pals))
# Read functions -----------------------------------
tool.path <- "../tools/"
# SScomm.R: the function that compute sums of squares of a square matrix according to a design matrix
source(paste0(tool.path,"SScomm.R"))
source(paste0(tool.path,"vec2sqmat.R"))
```

> This is an SVD with centered columns.

##### Data:

The data are from the morning scan club (MSC) resting-state data where the 2 participants (i.e., subjects 1 and 8 from the original study) were each scanned 10 times. The data that are analyzed here are the z-transformed coefficients of correlation between regions. These regions can be categorized into 12 networks: 

```{r community_list, echo = FALSE, fig.height= 10, fig.width = 2}
# rename communities
#--- read the file with community information: label number & community name & color & abbreviation for community name
parcel.comm.path <- "data/parcel_community"
CommName <- read.csv("../data/parcel_community/systemlabel.txt",header = FALSE)
colnames(CommName) <- c("Comm", "CommLabel","CommColor","CommLabel.short")
CommName[,'Community'] <- c("UnAssign", "Default","lateral Visual","Frontoparietal",
                            "medial Visual","dorsal Attention","Premotor",
                            "ventral Attention","Salience","Cingular opercular",
                            "Sensorimotor - hand","Sensorimotor - face","Auditory",
                            "anterior Medial temporal","posterior Medial temporal",
                            "Parietal memory","Context","Sensorimotor - foot","Unknown")
pander::pander(CommName[,c("Comm", "Community","CommLabel.short")])

```

As a result, the correlation matrix of each session of each subject will look like this:

```{r data, echo = FALSE, include = TRUE, fig.height= 20, fig.width = 16}
zmat.path <- "../data/zmat"
load(paste0(zmat.path,"/sub-MSC01_zcube_rcube.RData"))
# read parcel labels
parcel.comm.path <- "../data/parcel_community"
vox.des <- read.table(paste0(parcel.comm.path,"/sub-MSC01_node_parcel_comm.txt"),sep = ",")
colnames(vox.des) <- c("NodeID","VertexID","Comm")
#--- create three columns in the original table of community information: name, color, abbreviation
for(i in 1:nrow(CommName)){
  vox.des$Comm.recode[vox.des$Comm==CommName$Comm[i]] <- as.character(CommName$CommLabel[i])
  vox.des$Comm.Col[vox.des$Comm==CommName$Comm[i]] <- as.character(CommName$CommColor[i])
  vox.des$Comm.rcd[vox.des$Comm==CommName$Comm[i]] <- as.character(CommName$CommLabel.short[i])
}
#--- Create design matrix for communities
vox.des.mat <- makeNominalData(as.matrix(vox.des$Comm.rcd))
colnames(vox.des.mat) <- sub(".","",colnames(vox.des.mat))

#--- Create color for each communities
Comm.col <- list(oc = as.matrix(vox.des$Comm.Col), gc = as.matrix(CommName$CommColor))
rownames(Comm.col$oc) <- vox.des$NodeID
rownames(Comm.col$gc) <- CommName$CommLabel.short

superheat(cubes$rcube[,,1],
          membership.cols = vox.des$Comm.rcd,
          membership.rows = vox.des$Comm.rcd,
          clustering.method = NULL,
          heat.col.scheme = "viridis",
          left.label.size = 0.08,
          bottom.label.size = 0.05,
          y.axis.reverse = TRUE,
          left.label.col = Comm.col$gc[order(rownames(Comm.col$gc))], # order by community name
          bottom.label.col = Comm.col$gc[order(rownames(Comm.col$gc))],
          left.label.text.size = c(rep(6,4), rep(3,3),6,3,  rep(6,2),3,rep(6,5),3,3),
          bottom.label.text.size = 2,
          left.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
          bottom.label.text.col = c(rep("black",8),rep("white",2),rep("black",3),"white",rep("black",3),rep("white",2)),
          left.label.text.alignment = "left",
          title = "Correlation matric of the 1st session of Subject 1"
)
```

This correlation matrix were then turned into a rectangular matrix

##### Rectangular data:

+ Rows: 5 sessions

+ Columns: Different edges (e.g, _within DMN_, _between DMN & CON_, _between DMN & FPN_, etc.) of different subjects

_Note: The data was transformed from the upper triangle of the correlation matrices. From the correlation matrix of each session, its upper triangle are reshape as a vector. These reshaped vectors of different sessions are then concatenated on the rows and those of different subjects are concatenated on the columns._

```{r grandtable, echo = FALSE}
# > Read grand table of subject 1 --------------------
## grand table and the labels for each intersection of the correlation matirx
load(paste0("../data/grandatble_and_labels_MSC01_MSC08_20190312.Rdata")) # read the labels of grandtable
# gt: grand tabls
# labels: information for each edge in the rectangular grand table

## Categorize columns by between or within edges
#--- Create new column of sub-edgetype
gtlabel[,'subjects_wb'] <- sprintf('%s_%s',gtlabel$subjects_label,gtlabel$wb)

```


##### Method:

+ Centering: across sessions (rows) (i.e., the columns are centered)

+ Normalizing: none

```{r preproc_step}
# Centered across sessions
gt_preproc <- expo.scale(gt, center = TRUE, scale = FALSE)
# set the column names
colnames(gt_preproc) <- gtlabel$subjects_edge_label
# check dimension
dim(t(gt_preproc))
```

Then, the preprocessed data are decomposed by the SVD:

```{r svd}
svd.res <- epPCA(t(gt_preproc),scale = FALSE, center = FALSE, DESIGN = gtlabel$subjects_wb, make_design_nominal = TRUE, graphs = FALSE)

```

##### Results:

###### Scree plot

First, the scree plot illustrates the eigen value with percentage of explained variance of each component. The results showed that there are three important components with the percentage of explained variance more than average (i.e., 1/10).

```{r scree, echo = FALSE}
PlotScree(ev = svd.res$ExPosition.Data$t,
          title = "Compromise: Explained variance per dimension")

```

###### Contributions

Before checking the factor scores, we first plot the contributions to check the importance of network edges. The important edges are defined as those that with significant mean contribution to both components 1 and 2.

We first compute the contribution and find the important edges:

```{r contribution}
#--- get the contribution of each component
cI <- svd.res$ExPosition.Data$ci
#--- get the sum of contribution for each edge
c_edge <- gtlabel$subjects_edge_label %>% as.matrix %>% makeNominalData %>% t %>% "%*%"(cI)
rownames(c_edge) <- sub(".","",rownames(c_edge))
#--- compute the sums of squares of each variable for each component
absCtrEdg <- as.matrix(c_edge) %*% diag(svd.res$ExPosition.Data$eigs)
#--- get the contribution for component 1 AND 2 by sum(SS from 1, SS from 2)/sum(eigs 1, eigs 2)
edgCtr12 <- (absCtrEdg[,1] + absCtrEdg[,2])/(svd.res$ExPosition.Data$eigs[1] + svd.res$ExPosition.Data$eigs[2])
#--- the important variables are the ones that contribute more than or equal to the average
importantEdg <- (edgCtr12 >= 1/length(edgCtr12))
#--- find the between/within description for each network edge
net.edge <- matrix(NA, nrow = nrow(c_edge),ncol = 1)
for (i in 1:nrow(c_edge)){
  edge2check <- rownames(c_edge)[i]
  net.edge[i,1] <- unique(gtlabel[which(gtlabel$subjects_edge_label == edge2check),"subjects_wb"])
}
#--- create color based on the between/within description for network edges
net.edge.col <- net.edge %>% makeNominalData %>% createColorVectorsByDesign
rownames(net.edge.col$gc) <- sub(".","",rownames(net.edge.col$gc))
#--- color for networks
col4ImportantEdg <- net.edge.col$oc # get colors
col4NS <- 'gray90' # set color for not significant edges to gray
col4ImportantEdg[!importantEdg] <- col4NS # replace them in the color vector

```

Then the contributions are shown in plots

```{r plot_ci, echo=F, fig.show = 'hide'}
ciplot_all <- createFactorMap(c_edge,
                          axis1 = 1, axis2 = 2,
                          col.points = col4ImportantEdg,
                          text.cex = 2,
                          force = 0.5,
                          title = "Contibutions for all subject x edges")
ciplot_imp <- createFactorMap(c_edge[importantEdg,],
                          axis1 = 1, axis2 = 2,
                          col.points = col4ImportantEdg[importantEdg],
                          text.cex = 2,
                          force = 0.5,
                          title = "Significant contribution")
ciplot01 <- ciplot_all$zeMap_background + ciplot_all$zeMap_dots
ciplot02 <- ciplot_imp$zeMap_background + ciplot_imp$zeMap_dots + ciplot_imp$zeMap_text
```

```{r grid_ciplot, echo=F, fig.height=6, fig.width=12}
gridExtra::grid.arrange(as.grob(ciplot01), as.grob(ciplot02), ncol=2,
                        top = textGrob("Contribution plots",gp=gpar(fontsize=18,font=3)))
```

###### Factor scores

First, we plot the factor scores for the 10 sessions

```{r plot_f_sess, echo = FALSE}
plot.f_sess <- createFactorMap(svd.res$ExPosition.Data$fj) # with t(gt)
plot.f_sess$zeMap
```

To have a clearer view of the factor scores for the subject x edges, we first compute the mean factor scores for the each network edge.

```{r mean_fi}
# Compute means of factor scores for different edges----
mean.fi <- getMeans(svd.res$ExPosition.Data$fi, gtlabel$subjects_edge_label) # with t(gt)

# BootCube.Comm <- Boot4Mean(pca.res.subj$ExPosition.Data$fi,
#                            design = labels$subjects_edge_label,
#                            niter = 100,
#                            suppressProgressBar = TRUE)


# Compute means of factor scores for different types of edges
mean.fi.bw <- getMeans(svd.res$ExPosition.Data$fi, gtlabel$subjects_wb) # with t(gt)

# BootCube.Comm.bw <- Boot4Mean(pca.res.subj$ExPosition.Data$fi,
#                            design = labels$subjects_wb,
#                            niter = 100,
#                            suppressProgressBar = TRUE)

```

Next, we plot the factor scores for the subject x edges (a mess): Dim 1 & 2
```{r plot_f_edge, echo=FALSE, echo=F, fig.show = 'hide'}
# plot all factor scores
plot.f_edge <- createFactorMap(mean.fi, axis1 = 1, axis2 = 2,
                           col.points = net.edge.col$oc,
                           text.cex = 2,
                           force = 0.5,
                           title = "All factor scores - colored by subject_x_edge types")
f_netedge_plot01 <- plot.f_edge$zeMap_background + plot.f_edge$zeMap_dots
# plot the significantly contributed factor scores
plot.f_edge_imp <- createFactorMap(mean.fi, axis1 = 1, axis2 = 2,
                           col.points = col4ImportantEdg,
                           col.labels = col4ImportantEdg,
                           text.cex = 2,
                           force = 0.5,
                           title = "Significantly contributed factor scores - colored by subject_x_edge types")
f_netedge_plot02 <- plot.f_edge_imp$zeMap_background + plot.f_edge_imp$zeMap_dots
# plot mean factor scores of subject x edge type
plot.f_edge_imp <- createFactorMap(mean.fi.bw, axis1 = 1, axis2 = 2,
                           col.points = net.edge.col$gc[rownames(mean.fi.bw),],
                           col.labels = net.edge.col$gc[rownames(mean.fi.bw),],
                           text.cex = 2,
                           force = 0.5,
                           title = "Mean factor scores for subject_x_edge types")
f_netedge_plot03 <- plot.f_edge_imp$zeMap_background + plot.f_edge_imp$zeMap_dots + plot.f_edge_imp$zeMap_text

```

```{r grid_f_netedge_plot, echo=F, fig.height=12, fig.width=12}
gridExtra::grid.arrange(as.grob(f_netedge_plot01), as.grob(f_netedge_plot02),as.grob(f_netedge_plot03),nrow=2,
                        top = textGrob("Mean factor scores for edges",gp=gpar(fontsize=18,font=3)))
```

