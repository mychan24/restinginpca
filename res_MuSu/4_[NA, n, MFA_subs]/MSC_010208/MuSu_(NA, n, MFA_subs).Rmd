
---
title: "MuSu_(NA, n, MFA_subs) - MSC01, MSC02, MSC08 (bad sub)"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
suppressMessages(library(pander))
suppressMessages(library(psych))
suppressMessages(library(DistatisR))
suppressMessages(library(tidyr))
suppressMessages(library(magrittr))
suppressMessages(library(DistatisR))
suppressMessages(library(PTCA4CATA))
suppressMessages(library(ExPosition))
suppressMessages(library(InPosition))
suppressMessages(library(MExPosition))
suppressMessages(library(superheat))
suppressMessages(library(gridExtra))
suppressMessages(library(ggplotify))
suppressMessages(library(grid))
suppressMessages(library(pals))
# Read functions -----------------------------------
tool.path <- "../../../tools/"
source(paste0(tool.path,"SScomm.R")) # SScomm.R: computes sums of squares of a square matrix according to a design matrix
source(paste0(tool.path,"vec2sqmat.R"))
source(paste0(tool.path,"getVoxDes.R"))

#### == DEFINE Parameters (e.g., subj name, paths) == ####
# This section will hopefully become parameterized for RMD in the future 

parcelfile2read <- c("/sub-MSC01_node_parcel_comm.txt",
                     "/sub-MSC02_node_parcel_comm.txt",
                     "/sub-MSC08_node_parcel_comm.txt")
subj.name <- c("sub01","sub02", "sub08")

load(paste0("../../../data/grandatble_and_labels_MSC01_MSC08_20190312.Rdata")) # read the labels of grandtable
# gt: grand tabls
# labels: information for each edge in the rectangular grand table

## Categorize columns by between or within edges
#--- Create new column of sub-edgetype
gtlabel[,'subjects_wb'] <- sprintf('%s_%s',gtlabel$subjects_label,gtlabel$wb)

```

> This is an SVD with centered & normalized columns.

##### Data:

The data are from the morning scan club (MSC) resting-state data where the participants were each scanned 10 times. The data that are analyzed here are the z-transformed coefficients of correlation between regions. These regions can be categorized into 12 networks: 

```{r community_list, echo = FALSE, fig.height= 10, fig.width = 2}
# rename communities
#--- read the file with community information: label number & community name & color & abbreviation for community name
parcel.comm.path <- "../../../data/parcel_community"
CommName <- read.csv("../../../data/parcel_community/systemlabel.txt",header = FALSE)
colnames(CommName) <- c("Comm", "CommLabel","CommColor","CommLabel.short")
CommName[,'Community'] <- c("UnAssign", "Default","lateral Visual","Frontoparietal",
                            "medial Visual","dorsal Attention","Premotor",
                            "ventral Attention","Salience","Cingular opercular",
                            "Sensorimotor - hand","Sensorimotor - face","Auditory",
                            "anterior Medial temporal","posterior Medial temporal",
                            "Parietal memory","Context","Sensorimotor - foot", 
                            "Unknown","Unknown","Unknown","UnKnown","UnKnown")
pander::pander(CommName[,c("Comm", "Community","CommLabel.short")])

```

```{r data_info}
# read parcel labels for each subject
parcel.comm.path <- "../../../data/parcel_community"
parcel.list <- lapply(1:length(parcelfile2read), function(x){
                      parcel <- read.table(paste0(parcel.comm.path, parcelfile2read[x]),sep = ",")
                      getVoxDes(parcel,CommName)
                      })
names(parcel.list) <- subj.name

#-- Create colors for heatmap 
labelcol <- list()
textcol <- list()
for(i in 1:length(subj.name)){
  labelcol[[i]] <- parcel.list[[i]]$Comm.col$gc[order(rownames(parcel.list[[i]]$Comm.col$gc))]
  names(labelcol)[i] <- subj.name[i]
  
  textcol[[i]] <- rep("black", length(labelcol[[i]]))
  textcol[[i]][as(colorspace::hex2RGB(labelcol[[i]]), "polarLUV")@coords[,1] < 35] <- "white"  # Convert hex2RGB to lum
}

```

As a result, the correlation matrix of each session of each subject will look like this:

```{r data, echo = FALSE, include = FALSE, fig.show='hide'}
# ### Make these not objects, but part of a list? ### MYC NEED TO CHANGE 20190404
# # read examplar data
# zmat.path <- "../../../data/zmat"
# subj.num <- substr(subj.name, start = 4, stop = 6) # only works with format like "sub06" or "MSC06"
# #--- plot heatmap
# hmaplist <- list()
# hmaplist_i <- 1
# for(subj.count in 1:length(parcel.list)){
#   load(paste0(zmat.path,"/sub-MSC",subj.num[subj.count],"_zcube_rcube.RData"))
#   hmaplist[[subj.count]] <- list()
#   for(session.count in 1:dim(cubes$rcube)[3]){
#     # heat map of correlation matrices
#     hmap.name <- sprintf("sub%s_hmap%s",subj.num[subj.count],session.count)
#     hmaplist[[subj.count]][session.count] <- superheat(cubes$rcube[,,session.count],
#                                 membership.cols = parcel.list[[subj.count]]$vox.des$Comm.rcd,
#                                 membership.rows = parcel.list[[subj.count]]$vox.des$Comm.rcd,
#                                 clustering.method = NULL,
#                                 heat.col.scheme = "viridis",
#                                 left.label.size = 0.08,
#                                 bottom.label.size = 0.05,
#                                 y.axis.reverse = TRUE,
#                                 left.label.col = labelcol[[subj.count]], # order by community name
#                                 bottom.label.col = labelcol[[subj.count]],
#                                 left.label.text.size = 3,
#                                 bottom.label.text.size = 2,
#                                 left.label.text.col = textcol[[subj.count]],
#                                 bottom.label.text.col = textcol[[subj.count]],
#                                 left.label.text.alignment = "left",
#                                 title = sprintf("Correlation matrix of #%s session",session.count)
#                                 )
#     # hmaplist_i <- hmaplist_i + 1
#   }
# }

```

```{r plot_all_sub_session_hmap, echo=F, fig.height=(8*length(subj.name)), fig.width= 40}
# for(i in 1:length(hmaplist)){
#   print(sprintf("%s", subj.name[i]))
#   do.call(grid.arrange, c(hmaplist[[i]], ncol=5))
# }
```


This correlation matrix were then turned into a rectangular matrix

##### Rectangular data:

+ Rows: 5 sessions

+ Columns: Different edges (e.g, _within DMN_, _between DMN & CON_, _between DMN & FPN_, etc.) of different subjects

_Note: The data was transformed from the upper triangle of the correlation matrices. From the correlation matrix of each session, its upper triangle are reshape as a vector. These reshaped vectors of different sessions are then concatenated on the rows and those of different subjects are concatenated on the columns._

##### Method:

+ Centering: across sessions (rows) (i.e., the columns are centered)

+ Normalizing: across sessions (rows) (i.e., the columns are normalized); MFA normalized by subjects 

```{r preproc_step, include = FALSE, message=FALSE}
# Center Columns (across rows) + MFA normalize mini-block (Subjects)
cgt <- expo.scale(gt, center = T, scale = "ss1")
cgt[is.nan(cgt)] <- 0   # replace NaN with zero 

subtab_i <-  gtlabel$subjects_label     # Use subjects as mini table
n_subtable <- length(unique(subtab_i))  # Number of mini tables
sv <- matrix(NA, 1, n_subtable)     # Initialize eigenvalues object
for(i in 1:n_subtable){
  sv[i] <- (svd(cgt[,subtab_i==unique(subtab_i)[i]])$d[1]) # singular value from svd 
}
eigens <- sv^2

mfa_preproc <- cgt
for(i in 1:n_subtable){
   mfa_preproc[,subtab_i==unique(subtab_i)[i]] <- mfa_preproc[,subtab_i==unique(subtab_i)[i]]/sv[i]
}

## Not using mpSTATIS.preprocess so we can have sv and eigan saved out for partial factor score. 
## This also shows exact steps of normalization
# mfa_preproc <- mpSTATIS.preprocess(data = cgt, column.design = as.matrix(t(gtlabel$subjects_label)), row.design = NULL, 
#                                    row.preprocess = 'None', column.preprocess = 'None', # did col normalize with expo.scale 
#                                    table.preprocess = 'MFA_Normalization', 
#                                    make.columndesign.nominal = TRUE, make.rowdesign.nominal = TRUE)

# set the column names
gt_preproc <- mfa_preproc
gt_preproc[is.nan(gt_preproc)] <- 0   # replace NaN with zero 
colnames(gt_preproc) <- gtlabel$subjects_edge_label
# check dimension
dim(gt_preproc)
```

Then, the preprocessed data are decomposed by the SVD:

```{r svd, include = FALSE}
svd.res <- epPCA(gt_preproc,scale = FALSE, center = FALSE, graphs = FALSE)

```

##### Results:

###### Scree plot

First, the scree plot illustrates the eigen value with percentage of explained variance of each component. The results showed that there are three important components with the percentage of explained variance more than average (i.e., 1/10).

```{r scree, echo = FALSE}
PlotScree(ev = svd.res$ExPosition.Data$t,
          title = "Compromise: Explained variance per dimension")

```

###### Contributions

Before checking the factor scores, we first plot the contributions to check the importance of network edges. The important edges are defined as those that with significant mean contribution to both components 1 and 2.

We first compute the contribution and find the important edges and sessions:

```{r contribution}
#--- get the contribution of each component
cI <- svd.res$ExPosition.Data$ci
cJ <- svd.res$ExPosition.Data$cj
#--- get the sum of contribution for each edge
c_edge <- gtlabel$subjects_edge_label %>% as.matrix %>% makeNominalData %>% t %>% "%*%"(cJ)
rownames(c_edge) <- sub(".","",rownames(c_edge))
rownames(cI) <- c(1:10)
## Find important sessions
#--- get the contribution for component 1 AND 2 by sum(SS from 1, SS from 2)/sum(eigs 1, eigs 2)
sesCtr12 <- (cI[,1]+cI[,2])/(svd.res$ExPosition.Data$eigs[1] + svd.res$ExPosition.Data$eigs[2])
#--- the important sessions are the ones that contribute more than or equal to the average
importantSes <- (sesCtr12 >= 1/length(sesCtr12))
importantSes1 <- (cI[,1] >= 1/length(cI[,1]))
importantSes2 <- (cI[,2] >= 1/length(cI[,2]))
#--- color for sessions
col4ImportantSes <- as.matrix(rep("mediumorchid4",nrow(cI))) # get colors
col4NS <- 'gray48' # set color for not significant edges to gray
col4ImportantSes[!importantSes] <- col4NS # replace them in the color vector

## Find important edges
#--- compute the sums of squares of each variable for each component
absCtrEdg <- as.matrix(c_edge) %*% diag(svd.res$ExPosition.Data$eigs)
#--- get the contribution for component 1 AND 2 by sum(SS from 1, SS from 2)/sum(eigs 1, eigs 2)
edgCtr12 <- (absCtrEdg[,1] + absCtrEdg[,2])/(svd.res$ExPosition.Data$eigs[1] + svd.res$ExPosition.Data$eigs[2])
#--- the important variables are the ones that contribute more than or equal to the average
importantEdg <- (edgCtr12 >= 1/length(edgCtr12))
importantEdg1 <- (cI[,1] >= 1/length(cJ[,1]))
importantEdg2 <- (cI[,2] >= 1/length(cJ[,2]))
#--- find the between/within description for each network edge
net.edge <- matrix(NA, nrow = nrow(c_edge),ncol = 1)
for (i in 1:nrow(c_edge)){
  edge2check <- rownames(c_edge)[i]
  net.edge[i,1] <- unique(gtlabel[which(gtlabel$subjects_edge_label == edge2check),"subjects_wb"])
}
#--- create color based on the between/within description for network edges
net.edge.col <- net.edge %>% makeNominalData %>% createColorVectorsByDesign
rownames(net.edge.col$gc) <- sub(".","",rownames(net.edge.col$gc))
rownames(net.edge.col$oc) <- rownames(c_edge)
#--- color for networks
col4ImportantEdg <- net.edge.col$oc # get colors
col4NS <- 'gray90' # set color for not significant edges to gray
col4ImportantEdg[!importantEdg] <- col4NS # replace them in the color vector

```

```{r checkCtr, echo = FALSE, include = FALSE}
# f12 <- rowSums(mean.fj[,1:2])
# ftest <- svd.res$ExPosition.Data$fj[which(rownames(svd.res$ExPosition.Data$fi) == "sub02_21"),]
# col2test <- col4ImportantEdg_reg[which(rownames(col4ImportantEdg_reg) == "sub02_21")]
# fmaptest <- createFactorMap(ftest, col.points = col2test)
# fmaptest$zeMap_background+fmaptest$zeMap_dots
# sum(absCtrEdg["sub02_21",1:2])/sum(svd.res$ExPosition.Data$eigs[1:2])
# 1/length(absCtrEdg)
```


Then the contributions are shown in plots

```{r plot_ci, echo=F, fig.show = 'hide'}
ciplot <- createFactorMap(cI,
                              axis1 = 1, axis2 = 2,
                              col.points = col4ImportantSes,
                              text.cex = 5,
                              cex = 3,
                              force = 0.5,
                              title = "Contibutions for sessions")

cjplot_all <- createFactorMap(c_edge,
                              axis1 = 1, axis2 = 2,
                              col.points = col4ImportantEdg,
                              text.cex = 2,
                              force = 0.5,
                              title = "Contibutions for all subject x edges")
cjplot_imp <- createFactorMap(c_edge[importantEdg,],
                              axis1 = 1, axis2 = 2,
                              col.points = col4ImportantEdg[importantEdg],
                              col.labels = col4ImportantEdg[importantEdg],
                              text.cex = 2,
                              force = 0.5,
                              title = "Significant contribution")

f.labels <- createxyLabels.gen(x_axis = 1, y_axis = 2,
                               lambda = svd.res$ExPosition.Data$eigs,
                               tau = svd.res$ExPosition.Data$t,
                               axisName = "Dimension ")

ciplot01 <- ciplot$zeMap + f.labels
cjplot01 <- cjplot_all$zeMap_background + cjplot_all$zeMap_dots + f.labels
cjplot02 <- cjplot_imp$zeMap_background + cjplot_imp$zeMap_dots + cjplot_imp$zeMap_text + f.labels
```

```{r grid_ciplot, echo=F, fig.height=12, fig.width=12}
gridExtra::grid.arrange(as.grob(cjplot01), as.grob(cjplot02), as.grob(ciplot01),ncol=2,
                        top = textGrob("Contribution plots",gp=gpar(fontsize=18,font=3)))
```
The contribution for each network edge is computed by dividing its total SS across region edges and dimensions (i.e., the cross product of contribution and eigenvalues) by the total eigenvalues of the two components.

###### Factor scores

First, we plot the factor scores for the 10 sessions

```{r plot_f_sess, echo = FALSE}
# Change column names for fi for later use
colnames(svd.res$ExPosition.Data$fi) <- sapply(c(1:ncol(svd.res$ExPosition.Data$fi)), function(x) {sprintf("Dimension %s", x)})

# Plot factor scores
plot.f_sess <- createFactorMap(svd.res$ExPosition.Data$fi)
plot.f_sess$zeMap + f.labels
```

We can also compute the partial factor scores for each participant:

```{r partial_f_sess}
subj.table <- gtlabel$subjects_label
n_subj <- length(unique(gtlabel$subjects_label))
# compute partial factor scores: K x sv[1] x X_k x Q_k
pFi <- sapply(1:n_subj, function(x){
  n_subj/(sv[x])*cgt[,which(subj.table == unique(subj.table)[x])] %*% (svd.res$ExPosition.Data$pdq$q[which(subj.table == unique(subj.table)[x]),])
}, simplify = "array")
# name the dimension of the array that stores partial F
dimnames(pFi) <- list(rownames(cgt),colnames(svd.res$ExPosition.Data$fi),unique(subj.table))

## Check barycentric
# ch1 <- apply(pFi,c(1:2),mean)
# ch2 <- cgt %*% (svd.res$ExPosition.Data$pdq$q)
```

And plot them on the same factor map:

```{r plot_pf_sess, echo = FALSE}
# find the constraints for the pF map
pF.constraints <- minmaxHelper4Partial(
                                    FactorScores = svd.res$ExPosition.Data$fi,
                                    partialFactorScores = pFi)
# plot again the factor map
plot.f_sess4pF <- createFactorMap(svd.res$ExPosition.Data$fi,
                                  constraints = pF.constraints) # with t(gt)

# select color for subjects (subtables)
plot.pf_sess <- createPartialFactorScoresMap(
  factorScores = svd.res$ExPosition.Data$fi,
  partialFactorScores = pFi,
  axis1 = 1, axis2 = 2,
  # color4Items = col4ImportantSes,
  names4Partial = subj.name,
  font.labels = "bold"
)

# add it to the factor map ** MYC this broke when there is 3 subjects, ask JC 20190410
# plot.f_sess4pF$zeMap + f.labels + plot.pf_sess$mapColByBlocks
```
